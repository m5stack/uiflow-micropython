Index: M5GFX/src/M5GFX.cpp
===================================================================
--- M5GFX.orig/src/M5GFX.cpp
+++ M5GFX/src/M5GFX.cpp
@@ -1873,10 +1873,11 @@ The usage of each pin is as follows.
         bus_spi->release();
         for (auto pin: backup_pins) { pin.restore(); }
       }
-
+      
       if (board == 0 || board == board_t::board_M5StickS3)
       {
         gpio::pin_backup_t backup_pins[] = { GPIO_NUM_21, GPIO_NUM_39, GPIO_NUM_40, GPIO_NUM_41, GPIO_NUM_45, GPIO_NUM_47, GPIO_NUM_48 };
+        
         auto result = lgfx::gpio::command(
           (const uint8_t[]) {
           lgfx::gpio::command_mode_input_pulldown, GPIO_NUM_47,
@@ -1886,21 +1887,39 @@ The usage of each pin is as follows.
           lgfx::gpio::command_end
           }
         );
-        if (result == 0x03) {
-          _pin_reset(GPIO_NUM_21, use_reset); // LCD RST
-          bus_cfg.pin_mosi = GPIO_NUM_39;
-          bus_cfg.pin_miso = (gpio_num_t)-1; //GPIO_NUM_NC;
-          bus_cfg.pin_sclk = GPIO_NUM_40;
-          bus_cfg.pin_dc   = GPIO_NUM_45;
-          bus_cfg.spi_mode = 0;
-          bus_cfg.spi_3wire = true;
-          bus_spi->config(bus_cfg);
-          bus_spi->init();
-          id = _read_panel_id(bus_spi, GPIO_NUM_41);
-          if ((id & 0xFB) == 0x81) // 0x81 or 0x85
-          { //  check panel (ST7789)
-            board = board_t::board_M5StickS3;
+        if (result == 0x03) { // scl & sda pull-up
+          static constexpr uint8_t m5pm1_i2c_addr = 0x6E; // M5PM1 device i2c address
+          int i2c_speed = 100000;
+          lgfx::i2c::init(I2C_NUM_1, GPIO_NUM_47, GPIO_NUM_48); // SDA, SCL
+          auto chk_pm1 = lgfx::i2c::readRegister8(I2C_NUM_1, m5pm1_i2c_addr, 0x00, i2c_speed); // Try to read M5PM1 device id
+          if (chk_pm1.has_value()) {
             ESP_LOGI(LIBRARY_NAME, "[Autodetect] board_M5StickS3");
+            board = board_t::board_M5StickS3;     
+
+            // PM1_G2 -- L3B Enable, LCD Power On (M5Stack PM1 G2)
+            lgfx::i2c::bitOff(I2C_NUM_1, m5pm1_i2c_addr, 0x16, 1 << 2, i2c_speed); // Set pin gpio2 as gpio function
+            lgfx::i2c::bitOn(I2C_NUM_1, m5pm1_i2c_addr, 0x10, 1 << 2, i2c_speed);  // Set pin gpio2 mode: output
+            lgfx::i2c::bitOff(I2C_NUM_1, m5pm1_i2c_addr, 0x13, 1 << 2, i2c_speed); // Set gpio2 push-pull mode: reg:0x13
+            lgfx::i2c::bitOn(I2C_NUM_1, m5pm1_i2c_addr, 0x11, 1 << 2, i2c_speed);  // Set gpio2 output high: reg:0x05
+            // reg: 0x09(I2C_CFG) - Set to 0x00 to disable I2C idle sleep mode.
+            // PMIC is always-on powered, and with battery power, shutdown doesn't reset the chip.
+            // This register may have been modified elsewhere, causing PMIC communication issues.
+            // Explicitly set it here during initialization to ensure proper operation.
+            lgfx::i2c::writeRegister8(I2C_NUM_1, m5pm1_i2c_addr, 0x09, 0x00, i2c_speed);
+            lgfx::delay(100);
+
+            // LCD RST
+            _pin_reset(GPIO_NUM_21, use_reset); 
+            bus_cfg.pin_mosi = GPIO_NUM_39;
+            bus_cfg.pin_miso = GPIO_NUM_NC;
+            bus_cfg.pin_sclk = GPIO_NUM_40;
+            bus_cfg.pin_dc   = GPIO_NUM_45;
+            bus_cfg.spi_mode = 0;
+            bus_cfg.spi_3wire = true;
+            bus_spi->config(bus_cfg);
+            bus_spi->init();
+            lgfx::delay(100);
+
             bus_spi->release();
             bus_cfg.spi_host = SPI3_HOST;
             bus_cfg.freq_write = 40000000;
@@ -1914,30 +1933,19 @@ The usage of each pin is as follows.
               cfg.pin_rst = GPIO_NUM_21;
               cfg.panel_width = 135;
               cfg.panel_height = 240;
-              cfg.offset_x     = 52;
-              cfg.offset_y     = 40;
+              cfg.offset_x = 52;
+              cfg.offset_y = 40;
+              cfg.offset_rotation = 0;
               cfg.readable = true;
               cfg.invert = true;
               cfg.bus_shared = false;
               p->config(cfg);
             }
             _panel_last.reset(p);
-            _set_pwm_backlight(GPIO_NUM_38, 7, 44100, false, 0);
-  
-            static constexpr uint8_t py32pmic_i2c_addr = 0x6E;
-            lgfx::i2c::init(i2c_port, GPIO_NUM_47, GPIO_NUM_48);
-            uint8_t reg_tmp[8];
-            reg_tmp[3] = 0x04; // set read target = reg0x04
-            m5gfx::i2c::transactionWriteRead(i2c_port, py32pmic_i2c_addr, &reg_tmp[3], 1, &reg_tmp[4], 4, 100000);
-  // ::printf("PY32PMIC %02x %02x %02x %02x\n", reg_tmp[4], reg_tmp[5], reg_tmp[6], reg_tmp[7]);
-            reg_tmp[4] |= 0b00000100; // REG0x04 GPIO_MODE : gpio2 (PYG2_L3B_EN) set 1 (output mode)
-            reg_tmp[5] |= 0b00000100; // REG0x05 GPIO_OUT  : gpio2 (PYG2_L3B_EN) set 1 (HIGH)
-            reg_tmp[7] &= 0b11111011; // REG0x07 GPIO_DRV  : gpio2 (PYG2_L3B_EN) set 0 (push-pull)
-            m5gfx::i2c::transactionWrite(i2c_port, py32pmic_i2c_addr, &reg_tmp[3], 5, 100000);
-  
+            _set_pwm_backlight(GPIO_NUM_38, 7, 256, false, 16);
             goto init_clear;
           }
-          bus_spi->release();
+          lgfx::i2c::release(I2C_NUM_1);
         }
         for (auto pin: backup_pins) { pin.restore(); }
       }
