"""
This type stub file was generated by pyright.
"""

class RUI3:
    _instance = ...
    _recv_thread_running = ...
    def __init__(self, id, tx, rx, debug=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def get_received_data(self): # -> list[Any]:
        """Retrieve the data from the last received message.

        :returns: A tuple containing the port number (int) and the received data (bytes), or False if no data was received.
        :rtype: tuple[int, bytes] | bool

        MicroPython Code Block:

            .. code-block:: python

                data = lorawan_rui3.get_received_data()
                if data:
                    print(f"Received data: {data}")
                else:
                    print("No data received.")
        """
        ...
    
    def get_received_data_string(self) -> str:
        """Retrieve the received data as a string.

        :returns: The received data as a string, or an empty string if no data was received.
        :rtype: str

        MicroPython Code Block:

            .. code-block:: python

                data = lorawan_rui3.get_received_data_string()
                if data:
                    print(f"Received data: {data}")
                else:
                    print("No data received.")
        """
        ...
    
    def get_received_data_count(self): # -> int:
        """Retrieve the number of received data.

        :returns: The number of received data.
        :rtype: int

        MicroPython Code Block:

            .. code-block:: python

                count = lorawan_rui3.get_received_data_count()
                print(f"Received data count: {count}")
        """
        ...
    
    def send_cmd(self, cmd: str, have_return: bool = ..., is_single: bool = ..., async_event: bool = ..., timeout: int = ...) -> str | bool:
        ...
    
    def read_response(self, cmd, is_single=..., async_event=..., timeout=...): # -> LiteralString | bool:
        ...
    
    def get_commuinication_state(self): # -> str | bool:
        ...
    
    def reset_module(self): # -> None:
        ...
    
    def reset_module_to_default(self): # -> None:
        """Reset the module to its factory default settings.

        MicroPython Code Block:

            .. code-block:: python

                rui3.reset_module_to_default()
        """
        ...
    
    def get_serial_number(self) -> str | bool:
        ...
    
    def get_fireware_version(self): # -> str | bool:
        ...
    
    def get_at_version(self): # -> str | bool:
        ...
    
    def get_hardware_version(self): # -> str | bool:
        ...
    
    def get_hardware_id(self): # -> str | bool:
        ...
    
    def get_ble_mac(self): # -> str | bool:
        ...
    
    def set_sleep_time(self, time): # -> str | bool:
        ...
    
    def get_low_power_mode(self): # -> bool:
        ...
    
    def set_low_power_mode(self, mode: bool): # -> str | bool:
        ...
    
    def set_baud_rate(self, rate): # -> str | bool:
        ...
    
    def get_baud_rate(self): # -> int:
        ...
    
    def get_device_eui(self): # -> str | bool:
        """Get the device EUI.

        :returns: The device EUI.
        :rtype: str

        MicroPython Code Block:

            .. code-block:: python

                lorawan_rui3.get_device_eui()

        """
        ...
    
    def set_device_eui(self, eui: str): # -> str | bool:
        ...
    
    def get_app_eui(self): # -> str | bool:
        ...
    
    def set_app_eui(self, eui: str): # -> str | bool:
        ...
    
    def get_app_key(self): # -> str | bool:
        ...
    
    def set_app_key(self, key: str): # -> str | bool:
        ...
    
    def get_device_address(self): # -> str | bool:
        ...
    
    def set_device_address(self, address: str): # -> str | bool:
        ...
    
    def get_apps_key(self): # -> str | bool:
        ...
    
    def set_apps_key(self, key: str): # -> str | bool:
        ...
    
    def get_networks_key(self): # -> str | bool:
        ...
    
    def set_networks_key(self, key: str): # -> str | bool:
        ...
    
    def set_network_id(self, id: str): # -> str | bool:
        ...
    
    def get_network_id(self): # -> str | bool:
        ...
    
    def get_mc_root_key(self): # -> str | bool:
        ...
    
    def get_confirm_mode(self): # -> bool:
        ...
    
    def set_confirm_mode(self, mode: bool): # -> str | bool:
        ...
    
    def get_confirm_state(self): # -> bool:
        ...
    
    def get_join_config(self): # -> tuple[int, ...] | Literal[False]:
        ...
    
    def set_join_config(self, state: int, auto_join: int, reattempt_interval: int = ..., max_attempts: int = ..., timeout: int = ...): # -> str | bool:
        """Configure the join parameters for LoRaWAN.

        The configuration does not confirm network join success.

        :param int state: The join state to configure, as an integer.
        :param int auto_join: The auto-join flag, as an integer.
        :param int reattempt_interval: The interval between join retries, in seconds. Default is 8.
        :param int max_attempts: The maximum number of retries. Default is 0 (no limit).
        :param int timeout: The timeout duration in milliseconds for the command. Default is 8000ms.

        :returns: True if the command is successfully set, else False.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                lorawan_rui3.set_join_config(
                    state=1,
                    auto_join=1,
                    reattempt_interval=10,
                    max_attempts=5,
                    timeout=10000
                )
        """
        ...
    
    def join_network(self, timeout: int = ...): # -> bool | None:
        """Join the LoRa network using predefined join parameters.

        :param int timeout: The timeout duration in milliseconds for the join command. Default is 8000ms.

        :returns: True if the command is successfully set, else False.
        :rtype: bool

            |join_network_return.png|


        MicroPython Code Block:

            .. code-block:: python

                if lorawan_rui3.join_network(timeout=10000):
                    print("Network joined successfully!")
                else:
                    print("Failed to join network.")
        """
        ...
    
    def get_join_mode(self): # -> int:
        ...
    
    def set_join_mode(self, mode: int): # -> str | bool:
        """Set the join mode for the LoRa module.

        :param int mode: The join mode to set, 0 for ABP or 1 for OTAA.

        :returns: True if the command is successfully set, else False.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                lorawan_rui3.set_join_mode(1)  # Set to OTAA mode

        """
        ...
    
    def get_join_state(self): # -> bool:
        """Check whether the module has successfully joined the network.

        :returns: True if joined, otherwise False.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                if lorawan_rui3.get_join_state():
                    print("Module is joined to the network.")
                else:
                    print("Module is not joined to the network.")
        """
        ...
    
    def get_last_receive(self): # -> tuple[int, str] | Literal[False]:
        """Retrieve the data from the last received message.

        :returns: A tuple containing the port number (int) and the received data (bytes), or False if no data was received.
        :rtype: tuple[int, bytes] | bool

        MicroPython Code Block:

            .. code-block:: python

                last_data = lorawan_rui3.get_last_receive()
                if last_data:
                    port, data = last_data
                    print(f"Received data on port {port}: {data}")
                else:
                    print("No data received.")
        """
        ...
    
    def send_data(self, port: int, data: bytes | str, timeout: int = ...): # -> bool | None:
        """Send data through a specific port.

        :param int port: The port number to send data through.
        :param data: The data to send, provided as bytes or string(if data is bytes, it will be converted to string).
        :type data: bytes | str
        :param int timeout: The timeout duration in milliseconds for the send command. Default is 600ms.

        :returns: True if the data was sent successfully, otherwise False.
        :rtype: bool

            |send_data_return.png|

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.send_data(port=1, data=b"HelloLoRa", timeout=800)
                if success:
                    print("Data sent successfully!")
                else:
                    print("Failed to send data.")

        """
        ...
    
    def send_long_data(self, port: int, ack: bool, data: bytes, timeout: int = ...): # -> bool:
        ...
    
    def set_retry(self, retry: int): # -> str | bool:
        ...
    
    def get_retry(self): # -> int:
        ...
    
    def get_adaptive_rate_state(self): # -> bool:
        ...
    
    def set_adaptive_rate_state(self, state: bool): # -> str | bool:
        ...
    
    def get_lorawan_node_class(self): # -> str | bool:
        ...
    
    def set_lorawan_node_class(self, node_class: str): # -> str | bool:
        ...
    
    def get_duty_cycle_state(self): # -> bool:
        ...
    
    def set_duty_cycle_state(self, state: bool): # -> str | bool:
        ...
    
    def get_data_rate(self): # -> int:
        ...
    
    def set_data_rate(self, rate: int): # -> str | bool:
        ...
    
    def get_join_delay_on_window1(self): # -> int:
        ...
    
    def set_join_delay_on_window1(self, delay: int): # -> str | bool:
        ...
    
    def get_join_delay_on_window2(self): # -> int:
        ...
    
    def set_join_delay_on_window2(self, delay: int): # -> str | bool:
        ...
    
    def get_public_network_mode(self): # -> bool:
        ...
    
    def set_public_network_mode(self, mode: bool): # -> str | bool:
        ...
    
    def get_rx_delay_on_window1(self): # -> int:
        ...
    
    def set_rx_delay_on_window1(self, delay: int): # -> str | bool:
        ...
    
    def get_rx_delay_on_window2(self): # -> int:
        ...
    
    def set_rx_delay_on_window2(self, delay: int): # -> str | bool:
        ...
    
    def get_rx_data_rate_on_windows2(self): # -> int:
        ...
    
    def set_rx_data_rate_on_windows2(self, rate: int): # -> str | bool:
        ...
    
    def get_rx_frequency_on_windows2(self): # -> int:
        ...
    
    def get_tx_power(self): # -> int:
        ...
    
    def set_tx_power(self, power: int): # -> str | bool:
        ...
    
    def get_network_link_state(self): # -> str | bool:
        ...
    
    def set_network_link_state(self, state: int): # -> str | bool:
        ...
    
    def get_listen_before_talk(self): # -> bool:
        ...
    
    def set_listen_before_talk(self, state: bool): # -> str | bool:
        ...
    
    def set_listen_before_talk_rssi(self, rssi: int): # -> str | bool:
        ...
    
    def get_listen_before_talk_rssi(self): # -> int:
        ...
    
    def get_listen_before_talk_scan_time(self): # -> int:
        ...
    
    def set_listen_before_talk_scan_time(self, time: int): # -> str | bool:
        ...
    
    def get_time_request(self): # -> int:
        ...
    
    def set_time_request(self, state: bool): # -> str | bool:
        ...
    
    def get_location_time(self): # -> str | bool:
        ...
    
    def get_unicast_ping_interval(self): # -> int:
        ...
    
    def set_unicast_ping_interval(self, interval: int): # -> str | bool:
        ...
    
    def get_beacon_frequency(self): # -> int:
        ...
    
    def get_beacon_time(self): # -> int:
        ...
    
    def get_beacon_gateway_gps(self): # -> str | bool:
        ...
    
    def get_rssi(self): # -> str | bool:
        ...
    
    def get_all_rssi(self): # -> str | bool:
        ...
    
    def get_signal_noise_ratio(self): # -> str | bool:
        ...
    
    def get_channel_mask(self): # -> str | bool:
        ...
    
    def set_channel_mask(self, mask: str): # -> str | bool:
        ...
    
    def get_eight_channel_mode_state(self): # -> str | bool:
        ...
    
    def set_eight_channel_mode_state(self, max_group: int) -> bool:
        ...
    
    def get_single_channel_mode(self): # -> str | bool:
        ...
    
    def set_single_channel_mode(self, freq: int): # -> str | bool:
        ...
    
    def get_active_region(self): # -> str | bool:
        ...
    
    def set_active_region(self, region: int): # -> str | bool:
        ...
    
    def add_multicast_group(self, Class: str, DevAddr, NwkSKey, AppSKey, Frequency, Datarate, Periodicit): # -> str | bool:
        ...
    
    def remove_multicast_group(self, DevAddr): # -> str | bool:
        ...
    
    def get_multicast_list(self): # -> str | bool:
        ...
    
    def get_network_mode(self): # -> str | bool:
        ...
    
    def set_network_mode(self, mode: int): # -> str | bool:
        """Set the network mode for the device.

        :returns: The result of the AT command execution.
        :rtype: bool

        :param int mode: The mode to set for the network:

            - 0 = P2P_LORA
            - 1 = LoRaWAN
            - 2 = P2P_FSK

        MicroPython Code Block:

            .. code-block:: python

                lorawan_rui3.set_network_mode(0)  # Set to P2P_LORA mode
        """
        ...
    
    def get_p2p_frequency(self): # -> int:
        """Retrieve the current P2P frequency.

        :returns: The current P2P frequency as an integer.
        :rtype: int

        MicroPython Code Block:

            .. code-block:: python

                frequency = lorawan_rui3.get_p2p_frequency()
                print(f"Current P2P frequency: {frequency} Hz")
        """
        ...
    
    def set_p2p_frequency(self, frequency: int): # -> str | bool:
        """Set the P2P frequency for the device.

        :returns: The result of the AT command execution.
        :rtype: bool

        :param int frequency: The frequency to set for P2P communication.

            - Low-frequency range: 150000000-600000000
            - High-frequency range: 600000000-960000000

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_frequency(433000000)
                if success:
                    print("P2P frequency set successfully!")
                else:
                    print("Failed to set P2P frequency.")
        """
        ...
    
    def get_p2p_spreading_factor(self): # -> int:
        """Retrieve the current P2P spreading factor.

        :returns: The current P2P spreading factor as an integer.
        :rtype: int

        MicroPython Code Block:

            .. code-block:: python

                sf = lorawan_rui3.get_p2p_spreading_factor()
                print(f"Current P2P spreading factor: {sf}")
        """
        ...
    
    def set_p2p_spreading_factor(self, spreading_factor: int): # -> str | bool:
        """Set the P2P spreading factor.

        :param int spreading_factor: The spreading factor to set for P2P communication.

            - Range is 5 to 12.

        :returns: The result of the AT command execution.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_spreading_factor(10)
                if success:
                    print("P2P spreading factor set successfully!")
                else:
                    print("Failed to set P2P spreading factor.")
        """
        ...
    
    def get_p2p_bandwidth(self): # -> int:
        """Retrieve the current P2P bandwidth.

        :returns: The current P2P bandwidth as an integer.
        :rtype: int

        MicroPython Code Block:

            .. code-block:: python

                bw = lorawan_rui3.get_p2p_bandwidth()
                print(f"Current P2P bandwidth: {bw}")

        """
        ...
    
    def set_p2p_bandwidth(self, bandwidth: int): # -> str | bool:
        """Set the P2P bandwidth.

        :param int bandwidth: The bandwidth to set for P2P communication.

            - For LoRa:
                - 0 = 125 kHz
                - 1 = 250 kHz
                - 2 = 500 kHz
                - 3 = 7.8 kHz
                - 4 = 10.4 kHz
                - 5 = 15.63 kHz
                - 6 = 20.83 kHz
                - 7 = 31.25 kHz
                - 8 = 41.67 kHz
                - 9 = 62.5 kHz

            - For FSK:
                Range: 4800-467000 Hz

        :returns: The result of the AT command execution.
        :rtype: bool
            |set_p2p_fsk_bandwidth.png|

            |set_p2p_lora_bandwidth.png|

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_bandwidth(1)  # Set to 250 kHz
                if success:
                    print("P2P bandwidth set successfully!")
                else:
                    print("Failed to set P2P bandwidth.")
        """
        ...
    
    def get_p2p_code_rate(self): # -> int:
        """Retrieve the current P2P code rate.

        :returns: The current P2P code rate as an integer.
        :rtype: int

        MicroPython Code Block:

            .. code-block:: python

                code_rate = lorawan_rui3.get_p2p_code_rate()
                print(f"Current P2P code rate: {code_rate}")
        """
        ...
    
    def set_p2p_code_rate(self, code_rate: int): # -> str | bool:
        """Set the P2P code rate.

        :param int code_rate: The code rate to set for P2P communication.

                - 0 = 4/5
                - 1 = 4/6
                - 2 = 4/7
                - 3 = 4/8

        :returns: The result of the AT command execution.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_code_rate(1)  # Set to 4/6
                if success:
                    print("P2P code rate set successfully!")
                else:
                    print("Failed to set P2P code rate.")
        """
        ...
    
    def get_p2p_preamble_length(self): # -> int:
        """Retrieve the current P2P preamble length.

        :returns: The current P2P preamble length as an integer.
        :rtype: int

        MicroPython Code Block:

            .. code-block:: python

                preamble_length = lorawan_rui3.get_p2p_preamble_length()
                print(f"Current P2P preamble length: {preamble_length}")
        """
        ...
    
    def set_p2p_preamble_length(self, length: int): # -> str | bool:
        """Set the P2P preamble length.

        :returns: The result of the AT command execution.
        :rtype: bool

        :param int length: The preamble length to set for P2P communication.

            - Range is 5 to 65535.

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_preamble_length(16)
                if success:
                    print("P2P preamble length set successfully!")
                else:
                    print("Failed to set P2P preamble length.")
        """
        ...
    
    def get_p2p_tx_power(self): # -> int:
        """Retrieve the current P2P transmission power.

        :returns: The current P2P transmission power as an integer.
        :rtype: int

        MicroPython Code Block:

            .. code-block:: python

                tx_power = lorawan_rui3.get_p2p_tx_power()
                print(f"Current P2P transmission power: {tx_power} dBm")
        """
        ...
    
    def set_p2p_tx_power(self, power: int): # -> str | bool:
        """Set the P2P transmission power.

        :param int power: The transmission power to set for P2P communication.

            - Range is 5 to 22 dBm.

        :returns: The result of the AT command execution.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_tx_power(20)  # Set to 20 dBm
                if success:
                    print("P2P transmission power set successfully!")
                else:
                    print("Failed to set P2P transmission power.")
        """
        ...
    
    def get_p2p_fsk_bitrate(self): # -> int:
        """Retrieve the current P2P FSK bitrate.

        :returns: The result of the AT command execution.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                fsk_bitrate = lorawan_rui3.get_p2p_fsk_bitrate()
                print(f"Current P2P FSK bitrate: {fsk_bitrate} b/s")
        """
        ...
    
    def set_p2p_fsk_bitrate(self, bitrate: int): # -> str | bool:
        """Set the P2P FSK bitrate.

        :param int bitrate: The bitrate to set for P2P FSK communication.

            - Range is 600 to 300000 b/s.

        :returns: The result of the AT command execution.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_fsk_bitrate(9600)  # Set to 9600 b/s
                if success:
                    print("P2P FSK bitrate set successfully!")
                else:
                    print("Failed to set P2P FSK bitrate.")

        """
        ...
    
    def get_p2p_fsk_frequency_deviation(self): # -> int:
        ...
    
    def set_p2p_fsk_frequency_deviation(self, deviation: int): # -> str | bool:
        ...
    
    def send_p2p_data(self, payload: str, timeout: int = ..., to_hex: bool = ...): # -> bool | None:
        """Send P2P data with a given payload.

        :param str payload: The payload to send.

            - Length must be between 2 and 500 characters.
            - Must consist of an even number of characters composed of 0-9, a-f, A-F, representing 1 to 256 hexadecimal values.
        :param int timeout: The timeout for the data transmission, in milliseconds. Default is 1000 ms.
        :param bool to_hex: Indicates whether to convert the payload to hexadecimal format. Default is False.

        :returns: True if the data was sent successfully ("TXFSK DONE" or "TXP2P DONE"), False otherwise.
        :rtype: bool

            |send_p2p_data_return.png|

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.send_p2p_data("abcdef", timeout=2000, to_hex=True)
                if success:
                    print("P2P data sent successfully!")
                else:
                    print("Failed to send P2P data.")

        """
        ...
    
    def get_p2p_channel_activity(self): # -> int:
        ...
    
    def set_p2p_channel_activity(self, state: bool): # -> str | bool:
        ...
    
    def get_p2p_receive_data(self, timeout: int = ..., to_str: bool = ...): # -> tuple[int, int, str] | Literal[False]:
        """Receive data in P2P mode, including RSSI, SNR, and payload.

        :param int timeout: Timeout for listening to P2P LoRa data packets, in milliseconds.

                - Valid values are 1 to 65535.
                    - 0: Continuous listening.
                    - 65535: No timeout.

        :param bool to_str: Indicates whether to convert the payload to a string. Default is False.
        :returns: A tuple (RSSI, SNR, Payload) if data is received; False if no data is received.
        :rtype: tuple[int, int, str] | bool

        MicroPython Code Block:

            .. code-block:: python

                result = lorawan_rui3.get_p2p_receive_data(timeout=1000, to_str=True)
                if result:
                    rssi, snr, payload = result
                    print(f"Received data - RSSI: {rssi}, SNR: {snr}, Payload: {payload}")
                else:
                    print("No data received.")

        """
        ...
    
    def get_p2p_encryption_state(self): # -> int:
        ...
    
    def set_p2p_encryption_state(self, state: bool): # -> str | bool:
        ...
    
    def get_p2p_encryption_key(self): # -> str | bool:
        ...
    
    def set_p2p_encryption_key(self, key: str): # -> str | bool:
        ...
    
    def get_p2p_crypt_state(self): # -> int:
        ...
    
    def set_p2p_crypt_state(self, state: bool): # -> str | bool:
        ...
    
    def get_p2p_crypt_key(self): # -> str | bool:
        ...
    
    def set_p2p_crypt_key(self, key): # -> str | bool:
        ...
    
    def get_p2p_encryption_iv(self): # -> str | bool:
        ...
    
    def set_p2p_encryption_iv(self, iv: str): # -> str | bool:
        ...
    
    def get_p2p_parameters(self): # -> str | bool:
        ...
    
    def set_p2p_parameters(self, frequency: int = ..., spreading_factor: int = ..., bandwidth: int = ..., code_rate: int = ..., preamble_length: int = ..., tx_power: int = ...): # -> str | bool:
        ...
    
    def get_p2p_iq_inversion(self): # -> int:
        ...
    
    def set_p2p_iq_inversion(self, state: bool): # -> str | bool:
        ...
    
    def get_p2p_sync_word(self): # -> str | bool:
        """Get the current sync word in P2P mode.

        :returns: The sync word as a string.
        :rtype: str

        MicroPython Code Block:

            .. code-block:: python

                sync_word = lorawan_rui3.get_p2p_sync_word()
                print(f"Current P2P sync word: {sync_word}")

        """
        ...
    
    def set_p2p_sync_word(self, sync_word: int): # -> str | bool:
        """Set the sync word in P2P mode.

        :param int sync_word: The sync word value.

            - Must be in the range of 0x0000 to 0xFFFF.

        :returns: The response from the command execution.
        :rtype: bool

        MicroPython Code Block:

            .. code-block:: python

                success = lorawan_rui3.set_p2p_sync_word(0x1234)
                if success:
                    print("P2P sync word set successfully!")
                else:
                    print("Failed to set P2P sync word.")

        """
        ...
    
    def get_p2p_symbol_timeout(self): # -> int:
        ...
    
    def set_p2p_symbol_timeout(self, timeout): # -> str | bool:
        ...
    
    def get_p2p_fix_length_payload_state(self): # -> int:
        ...
    
    def set_p2p_fix_length_payload_state(self, state: bool): # -> str | bool:
        ...
    


