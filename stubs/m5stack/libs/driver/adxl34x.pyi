"""
This type stub file was generated by pyright.
"""

_ADXL345_DEFAULT_ADDRESS: int = ...
_ADXL345_MG2G_MULTIPLIER: float = ...
_STANDARD_GRAVITY: float = ...
_REG_DEVID: int = ...
_REG_THRESH_TAP: int = ...
_REG_OFSX: int = ...
_REG_OFSY: int = ...
_REG_OFSZ: int = ...
_REG_DUR: int = ...
_REG_LATENT: int = ...
_REG_WINDOW: int = ...
_REG_THRESH_ACT: int = ...
_REG_THRESH_INACT: int = ...
_REG_TIME_INACT: int = ...
_REG_ACT_INACT_CTL: int = ...
_REG_THRESH_FF: int = ...
_REG_TIME_FF: int = ...
_REG_TAP_AXES: int = ...
_REG_ACT_TAP_STATUS: int = ...
_REG_BW_RATE: int = ...
_REG_POWER_CTL: int = ...
_REG_INT_ENABLE: int = ...
_REG_INT_MAP: int = ...
_REG_INT_SOURCE: int = ...
_REG_DATA_FORMAT: int = ...
_REG_DATAX0: int = ...
_REG_DATAX1: int = ...
_REG_DATAY0: int = ...
_REG_DATAY1: int = ...
_REG_DATAZ0: int = ...
_REG_DATAZ1: int = ...
_REG_FIFO_CTL: int = ...
_REG_FIFO_STATUS: int = ...
_INT_SINGLE_TAP: int = ...
_INT_DOUBLE_TAP: int = ...
_INT_ACT: int = ...
_INT_INACT: int = ...
_INT_FREE_FALL: int = ...
class ADXL345:
    """Driver for the ADXL345 3 axis accelerometer.

    :param I2C i2c: The I2C bus the ADXL345 is connected to.
    :param int address: The I2C device address for the sensor. Default is
                        :const:`0x53`.

    **Quickstart: Importing and using the device**

        Here is an example of using the :class:`ADXL345` class.
        First you will need to import the libraries to use the sensor:

        .. code-block:: python

            import machine
            import adxl34x

        Once this is done you can define your `I2C` object and define your
        sensor object:

        .. code-block:: python

            i2c = machine.I2C(0)  # uses board default SDA and SCL pins
            accelerometer = adxl34x.ADXL343(i2c)

        Now you have access to the :attr:`acceleration` attribute:

        .. code-block:: python

            acceleration = accelerometer.acceleration

    """
    RATE_3200_HZ: int = ...
    RATE_1600_HZ: int = ...
    RATE_800_HZ: int = ...
    RATE_400_HZ: int = ...
    RATE_200_HZ: int = ...
    RATE_100_HZ: int = ...
    RATE_50_HZ: int = ...
    RATE_25_HZ: int = ...
    RATE_12_5_HZ: int = ...
    RATE_6_25HZ: int = ...
    RATE_3_13_HZ: int = ...
    RATE_1_56_HZ: int = ...
    RATE_0_78_HZ: int = ...
    RATE_0_39_HZ: int = ...
    RATE_0_20_HZ: int = ...
    RATE_0_10_HZ: int = ...
    RANGE_16_G: int = ...
    RANGE_8_G: int = ...
    RANGE_4_G: int = ...
    RANGE_2_G: int = ...
    def __init__(self, i2c, address: int | list | tuple = ...) -> None:
        ...
    
    @property
    def acceleration(self) -> tuple[int, int, int]:
        """The x, y, z acceleration values returned in a 3-tuple in :math:`m / s ^ 2`."""
        ...
    
    @property
    def raw_x(self) -> int:
        """The raw x value."""
        ...
    
    @property
    def raw_y(self) -> int:
        """The raw y value."""
        ...
    
    @property
    def raw_z(self) -> int:
        """The raw z value."""
        ...
    
    @property
    def events(self) -> dict[str, bool]:
        """
        :attr:`events` will return a dictionary with a key for each event type
        that has been enabled.

        The possible keys are:

        +------------+----------------------------------------------------------------------------+
        | Key        | Description                                                                |
        +============+============================================================================+
        | ``tap``    | True if a tap was detected recently. Whether it's looking for a single or  |
        |            | double tap is determined by the tap param of `enable_tap_detection`.       |
        +------------+----------------------------------------------------------------------------+
        | ``motion`` | True if the sensor has seen acceleration above the threshold               |
        |            | set with `enable_motion_detection`.                                        |
        +------------+----------------------------------------------------------------------------+
        |``freefall``| True if the sensor was in freefall. Parameters are set when enabled with   |
        |            | `enable_freefall_detection`.                                               |
        +------------+----------------------------------------------------------------------------+

        """
        ...
    
    def enable_motion_detection(self, *, threshold: int = ...): # -> None:
        """
        The activity detection parameters.

        :param int threshold: The value that acceleration on any axis must
                              exceed to register as active. The scale factor
                              is 62.5 mg/LSB.

        If you wish to set them yourself rather than using the defaults,
        you must use keyword arguments:

        .. code-block:: python

            accelerometer.enable_motion_detection(threshold=20)

        """
        ...
    
    def disable_motion_detection(self) -> None:
        """Disable motion detection."""
        ...
    
    def enable_freefall_detection(self, *, threshold: int = ..., time: int = ...) -> None:
        """
        Freefall detection parameters:

        :param int threshold: The value that acceleration on all axes must be
                              under to register as dropped. The scale factor is
                              62.5 mg/LSB.

        :param int time: The amount of time that acceleration on all axes must
                         be less than ``threshold`` to register as dropped. The
                         scale factor is 5 ms/LSB. Values between 100 ms and
                         350 ms (20 to 70) are recommended.

        If you wish to set them yourself rather than using the defaults,
        you must use keyword arguments:

        .. code-block:: python

            accelerometer.enable_freefall_detection(time=30)

        """
        ...
    
    def disable_freefall_detection(self) -> None:
        """Disable freefall detection."""
        ...
    
    def enable_tap_detection(self, *, tap_count: int = ..., threshold: int = ..., duration: int = ..., latency: int = ..., window: int = ...): # -> None:
        """
        The tap detection parameters.

        :param int tap_count: 1 to detect only single taps, and 2 to detect only
                              double taps.

        :param int threshold: A threshold for the tap detection. The scale
                              factor is 62.5 mg/LSB The higher the value the
                              less sensitive the detection.

        :param int duration: This caps the duration of the impulse above
                             ``threshold``. Anything above ``duration`` won't
                             register as a tap. The scale factor is 625 Âµs/LSB.

        :param int latency: (double tap only) The length of time after the
                            initial impulse falls below ``threshold`` to start
                            the window looking for a second impulse. The scale
                            factor is 1.25 ms/LSB.

        :param int window: (double tap only) The length of the window in which
                           to look for a second tap. The scale factor is
                           1.25 ms/LSB.

        If you wish to set them yourself rather than using the defaults,
        you must use keyword arguments:

        .. code-block:: python

            accelerometer.enable_tap_detection(duration=30, threshold=25)

        """
        ...
    
    def disable_tap_detection(self) -> None:
        """Disable tap detection."""
        ...
    
    @property
    def data_rate(self) -> int:
        """The data rate of the sensor."""
        ...
    
    @data_rate.setter
    def data_rate(self, val: int) -> None:
        ...
    
    @property
    def range(self) -> int:
        """The measurement range of the sensor."""
        ...
    
    @range.setter
    def range(self, val: int) -> None:
        ...
    
    @property
    def offset(self) -> tuple[int, int, int]:
        """
        The x, y, z offsets as a tuple of raw count values.

        See offset_calibration example for usage.
        """
        ...
    
    @offset.setter
    def offset(self, val: tuple[int, int, int]) -> None:
        ...
    


class ADXL343(ADXL345):
    """
    Stub class for the ADXL343 3-axis accelerometer.
    """
    ...


