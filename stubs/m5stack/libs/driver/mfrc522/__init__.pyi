"""
This type stub file was generated by pyright.
"""

import time
from .reg import AUTOTEST_REG, BITFRAMING_REG, COLL_REG, COMIRQ_REG, COMMAND_REG, CONTROL_REG, CRCRESULT_REGH, CRCRESULT_REGL, DIVIRQ_REG, ERROR_REG, FIFODATA_REG, FIFOLEVEL_REG, MODE_REG, RFCFG_REG, STATUS2_REG, TMODE_REG, TPRESCALER_REG, TRELOAD_REGH, TRELOAD_REGL, TXASK_REG, TXCONTROL_REG, VERSION_REG
from .cmd import PCD_CALCCRC, PCD_IDLE, PCD_MEM, PCD_MFAUTHENT, PCD_SOFTRESET, PCD_TRANSCEIVE, PICC_CMD_CT, PICC_CMD_HLTA, PICC_CMD_MF_AUTH_KEY_A, PICC_CMD_MF_AUTH_KEY_B, PICC_CMD_MF_DECREMENT, PICC_CMD_MF_INCREMENT, PICC_CMD_MF_READ, PICC_CMD_MF_RESTORE, PICC_CMD_MF_WRITE, PICC_CMD_REQA, PICC_CMD_SEL_CL1, PICC_CMD_SEL_CL2, PICC_CMD_SEL_CL3, PICC_CMD_UL_WRITE, PICC_CMD_WUPA
from .firmware import FM17522_firmware_reference, MFRC522_firmware_referenceV0_0, MFRC522_firmware_referenceV1_0, MFRC522_firmware_referenceV2_0

class UID:
    uid = ...
    sak = ...
    def __len__(self):
        ...
    
    def __getitem__(self, index):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class MFRC522:
    STATUS_OK = ...
    STATUS_ERROR = ...
    STATUS_COLLISION = ...
    STATUS_TIMEOUT = ...
    STATUS_NO_ROOM = ...
    STATUS_INTERNAL_ERROR = ...
    STATUS_INVALID = ...
    STATUS_CRC_WRONG = ...
    STATUS_MIFARE_NACK = ...
    PICC_TYPE_UNKNOWN = ...
    PICC_TYPE_ISO_14443_4 = ...
    PICC_TYPE_ISO_18092 = ...
    PICC_TYPE_MIFARE_MINI = ...
    PICC_TYPE_MIFARE_1K = ...
    PICC_TYPE_MIFARE_4K = ...
    PICC_TYPE_MIFARE_UL = ...
    PICC_TYPE_MIFARE_PLUS = ...
    PICC_TYPE_TNP3XXX = ...
    PICC_TYPE_NOT_COMPLETE = ...
    def __init__(self, i2c, addr) -> None:
        ...
    
    def pcd_init(self): # -> None:
        ...
    
    def pcd_reset(self): # -> None:
        ...
    
    def pcd_antenna_on(self): # -> None:
        ...
    
    def pcd_antenna_off(self): # -> None:
        """Turns the antenna off by disabling pins TX1 and TX2."""
        ...
    
    def pcd_get_antenna_gain(self):
        """Get the current MFRC522 Receiver Gain (RxGain[2:0]) value.
        See 9.3.3.6 / table 98 in http://www.nxp.com/documents/data_sheet/MFRC522.pdf
        NOTE: Return value scrubbed with (0x07<<4)=01110000b as RCFfgReg may use
              reserved bits.

        return Value of the RxGain, scrubbed to the 3 bits used.
        """
        ...
    
    def pcd_set_antenna_gain(self, mask): # -> None:
        """Set the MFRC522 Receiver Gain (RxGain) to value specified by given mask.
        See 9.3.3.6 / table 98 in http://www.nxp.com/documents/data_sheet/MFRC522.pdf
        NOTE: Given mask is scrubbed with (0x07<<4)=01110000b as RCFfgReg may
              use reserved bits.
        """
        ...
    
    def pcd_write_register(self, reg, val): # -> None:
        ...
    
    def pcd_read_register(self, reg):
        ...
    
    def pcd_set_register_bitmask(self, reg, mask): # -> None:
        ...
    
    def pcd_clear_register_bitmask(self, reg, mask): # -> None:
        ...
    
    def pcd_perform_self_test(self): # -> bool:
        """Performs a self-test of the MFRC522
        See 16.1.1 in http://www.nxp.com/documents/data_sheet/MFRC522.pdf

        @return Whether or not the test passed.
        """
        ...
    
    def pcd_transceive_data(self, send_data: bytearray, valid_bits=..., rx_align=..., check_crc=...): # -> tuple[Literal[4], None, Any | None] | tuple[Literal[2], None, Any | None] | tuple[Literal[3], bytearray | None, Any | None] | tuple[Literal[9], bytearray, Any | None] | tuple[Literal[8], bytearray, Any | None] | tuple[Literal[4], bytearray, Any | None] | tuple[Literal[1], bytearray | None, Any | None]:
        """Executes the Transceive command.
        CRC validation can only be done if back_data and backLen are specified.

        @return STATUS_OK on success, STATUS_??? otherwise.
        """
        ...
    
    def pcd_communicate_with_picc(self, command, wait_irq, send_data, valid_bits=..., rx_align=..., check_crc=...): # -> tuple[Literal[4], None, Any | None] | tuple[Literal[2], None, Any | None] | tuple[Literal[3], bytearray | None, Any | None] | tuple[Literal[9], bytearray, Any | None] | tuple[Literal[8], bytearray, Any | None] | tuple[Literal[4], bytearray, Any | None] | tuple[Literal[1], bytearray | None, Any | None]:
        ...
    
    def picc_request_a(self, buffer_atqa): # -> Literal[5, 4, 2, 3, 9, 8, 1]:
        ...
    
    def picc_wakeup_a(self, buffer_atqa): # -> Literal[5, 4, 2, 3, 9, 8, 1]:
        ...
    
    def picc_reqa_or_wupa(self, command, buffer_atqa): # -> Literal[5, 4, 2, 3, 9, 8, 1]:
        ...
    
    def picc_select(self, uid, valid_bits=...):
        """Transmits SELECT/ANTICOLLISION commands to select a single PICC.
        Before calling this function the PICCs must be placed in the READY(*) state by calling picc_request_a() or picc_wakeup_a().
        On success:
            - The chosen PICC is in state ACTIVE(*) and all other PICCs have returned to state IDLE/HALT. (Figure 7 of the ISO/IEC 14443-3 draft.)
            - The UID size and value of the chosen PICC is returned in *uid along with the SAK.

        A PICC UID consists of 4, 7 or 10 bytes.
        Only 4 bytes can be specified in a SELECT command, so for the longer UIDs two or three iterations are used:
            UID size    Number of UID bytes    Cascade levels    Example of PICC
            ========    ===================    ==============    ===============
            single                        4                 1    MIFARE Classic
            double                        7                 2    MIFARE Ultralight
            triple                       10                 3    Not currently in use?

            @return STATUS_OK on success, STATUS_??? otherwise.
        """
        ...
    
    def picc_halt_a(self): # -> Literal[4, 1, 2, 3, 9, 8]:
        ...
    
    def pcd_authenticate(self, command, block_addr, key, uid: UID): # -> Literal[4, 2, 3, 9, 8, 1]:
        ...
    
    def pcd_stop_crypto1(self): # -> None:
        ...
    
    def mifare_read(self, block_addr, buffer): # -> Literal[5, 4, 2, 3, 9, 8, 1]:
        ...
    
    def mifare_write(self, block_addr, buffer): # -> Literal[7, 4, 2, 3, 9, 8, 1]:
        ...
    
    def mifare_ultralight_write(self, page, buffer): # -> Literal[7, 4, 1, 2, 3, 9, 8]:
        ...
    
    def mifare_decrement(self, block_addr, delta): # -> Literal[7, 4, 2, 3, 9, 8, 1]:
        ...
    
    def mifare_increment(self, block_addr, delta): # -> Literal[7, 4, 2, 3, 9, 8, 1]:
        ...
    
    def mifare_restore(self, block_addr): # -> Literal[7, 4, 2, 3, 9, 8, 1]:
        ...
    
    def mifare_two_step_helper(self, command, block_addr, data): # -> Literal[7, 4, 2, 3, 9, 8, 1]:
        ...
    
    def mifare_transfer(self, block_addr): # -> Literal[7, 4, 1, 2, 3, 9, 8]:
        ...
    
    def mifare_get_value(self, block_addr): # -> tuple[Literal[1, 5, 4, 2, 3, 9, 8], int]:
        ...
    
    def mifare_set_value(self, block_addr, value): # -> Literal[7, 4, 2, 3, 9, 8, 1]:
        ...
    
    def pcd_mifare_transceive(self, send_data, acceptTimeout=...): # -> Literal[7, 4, 1, 2, 3, 9, 8]:
        ...
    
    def get_status_code_name(self, code): # -> str:
        ...
    
    def picc_get_type(self, sak): # -> int:
        """
        Translates the SAK (Select Acknowledge) to a PICC type.
        """
        ...
    
    def picc_get_type_name(self, picc_type): # -> str:
        ...
    
    def picc_dump_to_serial(self, uid: UID): # -> None:
        ...
    
    def picc_dump_mifare_classic_to_serial(self, uid, picc_type, key): # -> None:
        ...
    
    def picc_dump_mifare_classic_sector_to_serial(self, uid, key, sector): # -> None:
        ...
    
    def picc_dump_mifare_ultralight_to_serial(self): # -> None:
        ...
    
    def mifare_set_access_bits(self, access_bit_buffer, g0, g1, g2, g3): # -> None:
        ...
    
    def mifare_open_uid_backdoor(self, log_errors=...) -> bool:
        ...
    
    def mifare_set_uid(self, new_uid, log_errors=...) -> bool:
        ...
    
    def mifare_unbrick_uid_sector(self, log_errors=...) -> bool:
        ...
    
    def picc_is_new_card_present(self) -> bool:
        ...
    
    def picc_read_card_serial(self) -> bool:
        ...
    
    def pcd_calculate_crc(self, data, result): # -> Literal[4, 1]:
        ...
    
    def pcd_write_bytes(self, reg, data): # -> None:
        ...
    
    def pcd_read_bytes(self, reg, data, rx_align): # -> None:
        ...
    


