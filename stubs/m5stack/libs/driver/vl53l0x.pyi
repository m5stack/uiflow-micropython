"""
This type stub file was generated by pyright.
"""

from machine import I2C
from typing import Optional, Type
from types import TracebackType

"""
This type stub file was generated by pyright.
"""
_SYSRANGE_START = ...
_SYSTEM_THRESH_HIGH = ...
_SYSTEM_THRESH_LOW = ...
_SYSTEM_SEQUENCE_CONFIG = ...
_SYSTEM_RANGE_CONFIG = ...
_SYSTEM_INTERMEASUREMENT_PERIOD = ...
_SYSTEM_INTERRUPT_CONFIG_GPIO = ...
_GPIO_HV_MUX_ACTIVE_HIGH = ...
_SYSTEM_INTERRUPT_CLEAR = ...
_RESULT_INTERRUPT_STATUS = ...
_RESULT_RANGE_STATUS = ...
_RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN = ...
_RESULT_CORE_RANGING_TOTAL_EVENTS_RTN = ...
_RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF = ...
_RESULT_CORE_RANGING_TOTAL_EVENTS_REF = ...
_RESULT_PEAK_SIGNAL_RATE_REF = ...
_ALGO_PART_TO_PART_RANGE_OFFSET_MM = ...
_I2C_SLAVE_DEVICE_ADDRESS = ...
_MSRC_CONFIG_CONTROL = ...
_PRE_RANGE_CONFIG_MIN_SNR = ...
_PRE_RANGE_CONFIG_VALID_PHASE_LOW = ...
_PRE_RANGE_CONFIG_VALID_PHASE_HIGH = ...
_PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT = ...
_FINAL_RANGE_CONFIG_MIN_SNR = ...
_FINAL_RANGE_CONFIG_VALID_PHASE_LOW = ...
_FINAL_RANGE_CONFIG_VALID_PHASE_HIGH = ...
_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT = ...
_PRE_RANGE_CONFIG_SIGMA_THRESH_HI = ...
_PRE_RANGE_CONFIG_SIGMA_THRESH_LO = ...
_PRE_RANGE_CONFIG_VCSEL_PERIOD = ...
_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI = ...
_PRE_RANGE_CONFIG_TIMEOUT_MACROP_LO = ...
_SYSTEM_HISTOGRAM_BIN = ...
_HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT = ...
_HISTOGRAM_CONFIG_READOUT_CTRL = ...
_FINAL_RANGE_CONFIG_VCSEL_PERIOD = ...
_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI = ...
_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_LO = ...
_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS = ...
_MSRC_CONFIG_TIMEOUT_MACROP = ...
_SOFT_RESET_GO2_SOFT_RESET_N = ...
_IDENTIFICATION_MODEL_ID = ...
_IDENTIFICATION_REVISION_ID = ...
_OSC_CALIBRATE_VAL = ...
_GLOBAL_CONFIG_VCSEL_WIDTH = ...
_GLOBAL_CONFIG_SPAD_ENABLES_REF_0 = ...
_GLOBAL_CONFIG_SPAD_ENABLES_REF_1 = ...
_GLOBAL_CONFIG_SPAD_ENABLES_REF_2 = ...
_GLOBAL_CONFIG_SPAD_ENABLES_REF_3 = ...
_GLOBAL_CONFIG_SPAD_ENABLES_REF_4 = ...
_GLOBAL_CONFIG_SPAD_ENABLES_REF_5 = ...
_GLOBAL_CONFIG_REF_EN_START_SELECT = ...
_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD = ...
_DYNAMIC_SPAD_REF_EN_START_OFFSET = ...
_POWER_MANAGEMENT_GO1_POWER_FORCE = ...
_VHV_CONFIG_PAD_SCL_SDA_EXTSUP_HV = ...
_ALGO_PHASECAL_LIM = ...
_ALGO_PHASECAL_CONFIG_TIMEOUT = ...
_VCSEL_PERIOD_PRE_RANGE = ...
_VCSEL_PERIOD_FINAL_RANGE = ...
class VL53L0X:
    """Create an VL53L0X object.

    :param I2C i2c: The I2C bus the VL53L0X is connected to.
    :param int address: The I2C address of VL53L0X. Default is 0x29.
    :param int io_timeout_ms: The timeout for the I/O operations. Default is 0.

    MicroPython Code Block:

        .. code-block:: python

            from driver import VL53L0X

            i2c0 = I2C(0, scl=Pin(1), sda=Pin(2), freq=100000)
            vl53l0x_0 = VL53L0X(i2c0)
    """
    _BUFFER = ...
    _continuous_mode = ...
    def __init__(self, i2c: I2C, address: int = ..., io_timeout_ms: int = ...) -> None:
        ...
    
    def get_signal_rate_limit(self) -> float:
        ...
    
    def set_signal_rate_limit(self, val: float) -> None:
        ...
    
    def get_measurement_timing_budget(self) -> int:
        """Get the measurement timing budget in microseconds.

        :returns: The measurement timing budget in microseconds.
        :rtype: int

        UiFlow2 Code Block:

            |get_measurement_timing_budget.png|

        MicroPython Code Block:

            .. code-block:: python

                budget_ms = vl53l0x_0.get_measurement_timing_budget()
        """
        ...
    
    def set_measurement_timing_budget(self, budget_us: int) -> None:
        """Set the measurement timing budget in microseconds.

        :param int budget_us: The measurement timing budget in microseconds(range 20000 - 200000).

        UiFlow2 Code Block:

            |get_measurement_timing_budget.png|

        MicroPython Code Block:

            .. code-block:: python

                budget_ms = vl53l0x_0.get_measurement_timing_budget()
        """
        ...
    
    def get_distance(self) -> float:
        """Perform a single reading of the range for an object in front of the sensor and return the distance in centimeters.

        :returns: The distance in centimeters.
        :rtype: float

        MicroPython Code Block:

            .. code-block:: python

                distance = vl53l0x_0.get_distance()
        """
        ...
    
    def get_range(self) -> int:
        """Perform a single reading of the range for an object in front of the sensor and return the distance in millimeters.

        :returns: The distance in millimeters.
        :rtype: float

        UiFlow2 Code Block:

            |get_range.png|

        MicroPython Code Block:

            .. code-block:: python

                distance = vl53l0x_0.get_range()
        """
        ...
    
    def get_data_ready(self) -> bool:
        """Get the data ready status of the sensor.

        :returns: The data ready status of the sensor.
        :rtype: bool

        UiFlow2 Code Block:

            |get_data_ready.png|

        MicroPython Code Block:

            .. code-block:: python

                data_ready = vl53l0x_0.get_data_ready()
        """
        ...
    
    def do_range_measurement(self) -> None:
        """Perform a single reading of the range for an object in front of the
        sensor, but without return the distance.
        """
        ...
    
    def read_range(self) -> int:
        """Return a range reading in millimeters.
        Note: Avoid calling this directly. If you do single mode, you need
        to call `do_range_measurement` first. Or your program will stuck or
        timeout occurred.
        """
        ...
    
    def is_continuous_mode(self) -> bool:
        """
        Get the continuous mode status of the sensor.

        :returns: The continuous mode status of the sensor.
        :rtype: bool

        UiFlow2 Code Block:

            |is_continuous_mode.png|

        MicroPython Code Block:

            .. code-block:: python

                continuous_mode = vl53l0x_0.is_continuous_mode()
        """
        ...
    
    def continuous_mode(self) -> VL53L0X:
        """Activate the continuous mode manager"""
        ...
    
    def __enter__(self) -> VL53L0X:
        """For continuous mode manager, called when used on `with` keyword"""
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> None:
        """For continuous mode manager, called at the end of `with` scope"""
        ...
    
    def start_continuous(self) -> None:
        """
        Set the sensor to continuous mode.

        UiFlow2 Code Block:

            |start_continuous.png|

        MicroPython Code Block:

            .. code-block:: python

                vl53l0x_0.start_continuous()
        """
        ...
    
    def stop_continuous(self) -> None:
        """
        Set the sensor to single ranging mode.

        UiFlow2 Code Block:

            |stop_continuous.png|

        MicroPython Code Block:

            .. code-block:: python

                vl53l0x_0.stop_continuous()
        """
        ...
    
    def set_address(self, new_address: int = ...) -> None:
        """
        Set a new I2C address to the sensor.

        :param int new_address: The 7-bit int that is to be assigned to the VL53L0X sensor.

        UiFlow2 Code Block:

            |set_address.png|

        MicroPython Code Block:

            .. code-block:: python

                vl53l0x_0.set_address(0x2A)
        """
        ...
    


