# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016 - 2025 M5Stack Technology Co., Ltd
# This file is distributed under the same license as the UIFlow2 Programming
# Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: UIFlow2 Programming Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 14:29+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../en/base/rs232.rst:2 d14d4450e5104e3ab4ed75ad6870ee7f
msgid "Atomic RS232 Base"
msgstr ""

#: ../../en/base/rs232.rst:8 c6857c8e582043bd85e9d87289eb355c
msgid ""
"AtomRS232 Class provides a set of methods to control the RS232 module. "
"Through the UART interface, the module can transmit and receive data, "
"supporting various baud rates and flow control configurations."
msgstr "AtomRS232 类提供了一套控制 RS232 模块的方法。通过 UART 接口，模块可以发送和接收数据，支持各种波特率和流量控制配置。"

#: ../../en/base/rs232.rst:12 0b7e2d57a7c1408c90b197552b6085f7
msgid "Support the following products:"
msgstr "支持以下产品："

#: ../../en/base/rs232.rst:15 39ae54438cb143cb864138ea065261ef
msgid "|RS232 Base|"
msgstr ""

#: ../../en/refs/base.rs232.ref 2c27b578cf2143b2826973f4e6a62386
msgid "rs232 base"
msgstr ""

#: ../../en/base/rs232.rst:15 c583a26e9f1b4e828fea31f9105b5c4a
msgid "|RS232|"
msgstr ""

#: ../../en/refs/base.rs232.ref 01f6b7d7b6764187b5cf634f0d047e98
msgid "rs232"
msgstr ""

#: ../../en/base/rs232.rst:19 65123ac4a8124bfe8a97bc1ea20300a5
#, fuzzy
msgid "UiFlow2 Example"
msgstr "UIFLOW2 发送/接收应用示例："

#: ../../en/base/rs232.rst:22 ../../en/base/rs232.rst:40
#: 3a3ed69043db421290dd729d6b56c05b
#, fuzzy
msgid "RS232 Example"
msgstr "UIFLOW2 发送/接收应用示例："

#: ../../en/base/rs232.rst:24 552ea66f39da448ba4e491395908efbd
msgid "Open the |atoms3r_rs232_example.m5f2| project in UiFlow2."
msgstr "在 UiFlow2 中打开 |atoms3r_rs232_example.m5f2| 项目。"

#: ../../en/base/rs232.rst:26 ../../en/base/rs232.rst:42
#: 2744cbae30724bc9b7222e849ba7ef34
msgid ""
"This example demonstrates how to send and receive data using the RS232 "
"module via the UART interface."
msgstr "本示例演示如何使用 RS232 模块通过 UART 接口发送/接收数据。"

#: ../../en/base/rs232.rst:28 ../../en/base/rs232.rst:72
#: ../../en/base/rs232.rst:86 ../../en/base/rs232.rst:103
#: ../../en/base/rs232.rst:121 ../../en/base/rs232.rst:145
#: ../../en/base/rs232.rst:164 ../../en/base/rs232.rst:183
#: ../../en/base/rs232.rst:210 ../../en/base/rs232.rst:226
#: ../../en/base/rs232.rst:243 c32ee538ee0d4d2096f0af6b2ef46d4c
msgid "UiFlow2 Code Block:"
msgstr "UiFlow2 代码块："

#: ../../en/base/rs232.rst:30 12587e6c3eb6435db043e7b14ee4f135
#, fuzzy
msgid "|example.png|"
msgstr "UIFLOW2 发送应用示例："

#: ../../en/refs/base.rs232.ref:30 41340a2b1e0e4c199ad38222bb0824ba
#, fuzzy
msgid "example.png"
msgstr "UIFLOW2 发送应用示例："

#: ../../en/base/rs232.rst:32 ../../en/base/rs232.rst:50
#: 136f42c640414beba3eccf531c369737
msgid "Example output:"
msgstr "示例输出："

#: ../../en/base/rs232.rst:34 ../../en/base/rs232.rst:52
#: ../../en/base/rs232.rst:208 ../../en/base/rs232.rst:224
#: 2b69f4b4200247cf8eb1c0741e907aef 8819ea98b3874eff94064fa2d26f8466
msgid "None"
msgstr ""

#: ../../en/base/rs232.rst:37 33705eb1532d46278d54b7a1b1a45f85
#, fuzzy
msgid "MicroPython Example"
msgstr "MicroPython 发送应用示例："

#: ../../en/base/rs232.rst:44 ../../en/base/rs232.rst:76
#: ../../en/base/rs232.rst:90 ../../en/base/rs232.rst:107
#: ../../en/base/rs232.rst:129 ../../en/base/rs232.rst:149
#: ../../en/base/rs232.rst:168 ../../en/base/rs232.rst:198
#: ../../en/base/rs232.rst:214 ../../en/base/rs232.rst:230
#: ../../en/base/rs232.rst:247 b941474ed8134887ab8b669ff2931b6d
msgid "MicroPython Code Block:"
msgstr "MicroPython 代码块："

#: ../../en/base/rs232.rst:55 46add43bde4c42559accc22b5723d665
#, fuzzy
msgid "**API**"
msgstr ""

#: ../../en/base/rs232.rst:58 1f01d5d3e1e143e78caa686bac5ac756
msgid "AtomRS232"
msgstr ""

#: 93ed676550904fe4a15abad1217ba261 base.rs232.AtomRS232:1 of
msgid "Bases: :py:class:`object`"
msgstr ""

#: ../../en/base/rs232.rst:65 1d706932de374e2192ff4008070584a6
msgid "Initialize the UART bus with the given parameters."
msgstr "使用给定参数初始化 UART 总线。"

#: ../../en/base/rs232.rst 0c1ecaaf2a454705a12b5967da7e34b8
msgid "Parameters"
msgstr ""

#: ../../en/base/rs232.rst:67 03474186b17d4d278c1a1e833ede541a
msgid "The clock rate for the UART communication."
msgstr "UART 通信的时钟频率。"

#: ../../en/base/rs232.rst:68 a4e548a18f7a49cf870d33afb5e28db4
msgid "Number of bits per character (7, 8, or 9)."
msgstr "每个字符的位数（7、8 或 9）。"

#: ../../en/base/rs232.rst:69 f7d063d6e3a04c89af9e635233d3dbb0
msgid "Parity setting, either None, 0 (even), or 1 (odd)."
msgstr "奇偶校验设置，无、0（偶）或 1（奇）。"

#: ../../en/base/rs232.rst:70 79034b685a6a4d55b846fdb1538d476e
msgid "Number of stop bits (1 or 2)."
msgstr "停止位数（1 或 2）。"

#: ../../en/base/rs232.rst:74 31bb268ad333478cad88b76460be4acc
msgid "|setup.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:14 ca4d1e7c4c194b55b9683e557df29859
msgid "setup.png"
msgstr ""

#: ../../en/base/rs232.rst:84 859abad76a9443d18b408e44ea51bef5
msgid "Turn off the UART bus."
msgstr "关闭 UART 总线。"

#: ../../en/base/rs232.rst:88 225e42d98bed44fcbcc143ea3aa6055b
msgid "|deinit.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:13 3c832199a3a64bb39d15460563e127ba
msgid "deinit.png"
msgstr ""

#: ../../en/base/rs232.rst:98 198855ae2ac44b1196b751e82dffcad3
msgid "Returns the number of characters that can be read without blocking."
msgstr "返回无阻塞情况下可读取的字符数。"

#: ../../en/base/rs232.rst 35ec127a5e1c4fbfae24893bfea1824e
msgid "Returns"
msgstr ""

#: ../../en/base/rs232.rst:100 c1ddb7132cac499e96d490497c49c3aa
msgid "The number of available bytes."
msgstr "可用字节数。"

#: ../../en/base/rs232.rst 53bdd82ee075460ca560a22091b8a84c
msgid "Return type"
msgstr "返回类型"

#: ../../en/base/rs232.rst:105 7c744ea1a00d467895623cf87674172b
msgid "|any.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:12 9245384f541c40798b2efca9ab561c54
msgid "any.png"
msgstr ""

#: ../../en/base/rs232.rst:115 d0411d4d8aef4d97b1a01ebdd44f99be
msgid "Read characters from the UART buffer."
msgstr "从 UART 缓冲器读取字符。"

#: ../../en/base/rs232.rst:117 7cf73a28939c4d27a09f66c548d7a39b
msgid "The maximum number of bytes to read (optional)."
msgstr "要读取的最大字节数（可选）。"

#: ../../en/base/rs232.rst:118 2d39dd3cfc5548ebb2ca74bfeeed31a6
msgid "A bytes object containing the data read."
msgstr "包含已读取数据的字节对象。"

#: ../../en/base/rs232.rst:123 a3e4eafdda4143279ecbf042c68ac637
msgid "|read_all.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:15 b89f009fe9c44d6e937d47dd95ac2fea
msgid "read_all.png"
msgstr ""

#: ../../en/base/rs232.rst:125 45eeac565b0543c3b34771099f832ba8
msgid "|read_bytes.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:16 e39b63e7a3ee42279e3e38f6ce96ed02
msgid "read_bytes.png"
msgstr ""

#: ../../en/base/rs232.rst:127 e01d8b8b6148470782b3dd35ed3c8246
msgid "|read_raw_data.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:17 3e89f1ebe6fc40348b798462f17751c0
msgid "read_raw_data.png"
msgstr ""

#: ../../en/base/rs232.rst:137 571f74e165d44f9380107713edfa862f
msgid ""
"Read bytes into the ``buf``. If ``nbytes`` is specified, read at most "
"that many bytes; otherwise, read at most ``len(buf)`` bytes. It may "
"return sooner if a timeout is reached. The timeout is configurable in the"
" constructor."
msgstr ""
"向 ``buf`` 中读取字节。如果指定了 ``nbytes`` 字节，则最多读取这么多字节；否则，最多读取 ``len(buf)`` "
"字节。如果超时，可能会提前返回。超时可在构造函数中配置。"

#: ../../en/base/rs232.rst:139 194c82a69e944eb5898be708ecfb8190
msgid "The buffer into which the bytes will be read."
msgstr "读取字节的缓冲区。"

#: ../../en/base/rs232.rst:140 6ef6580b634a44b7816244fc421932f2
msgid "(Optional) The maximum number of bytes to read."
msgstr "(可选）要读取的最大字节数。"

#: ../../en/base/rs232.rst:142 c98baaeef5384153870d8ea8c0e75f5e
msgid ""
"The number of bytes read and stored into ``buf``, or ``None`` if a "
"timeout occurs."
msgstr "读取并存储到 ``buf`` 中的字节数，如果超时则为 ``None``。"

#: ../../en/base/rs232.rst:147 63c0af65bf7e47d586175639f578447a
msgid "|readinto.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:19 c2c90a8397ae46f2936fd89218c5656d
msgid "readinto.png"
msgstr ""

#: ../../en/base/rs232.rst:159 8d39861858764f10abc4241d9a2448aa
msgid ""
"Read a line ending in a newline character. It may return sooner if a "
"timeout is reached. The timeout is configurable in the constructor."
msgstr "读取以换行符结束的一行。如果超时，可能会提前返回。超时可在构造函数中配置。"

#: ../../en/base/rs232.rst:161 60e9cc3384f8405d987fba3d1e683a4a
msgid "The line read as bytes, or ``None`` if a timeout occurs."
msgstr "读取的行以字节为单位，如果超时则返回 ``无``。"

#: ../../en/base/rs232.rst:166 2b0f1e1d56ef47d79652e5f2305202ef
msgid "|readline.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:18 f2bf71177a1b44c3a558b4aac4535abf
msgid "readline.png"
msgstr ""

#: ../../en/base/rs232.rst:177 14895a63b2694dc1b22572518204142e
msgid "Write data to the UART interface."
msgstr "向 UART 接口写入数据。"

#: ../../en/base/rs232.rst:179 94e384da37314b92bebbed8b1d41720f
msgid "The data to be written."
msgstr "要写入的数据。"

#: ../../en/base/rs232.rst:180 6a8c085ea5d14c1dac72fbafc069e6c4
msgid "The number of bytes written."
msgstr "写入的字节数。"

#: ../../en/base/rs232.rst:185 79eef58aeb3441b5b6bea67a3d0f6d42
msgid "|write.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:20 6a05dce6c67446be936411b689230ab6
msgid "write.png"
msgstr ""

#: ../../en/base/rs232.rst:187 f7b3889f6aad462684d769279b816eb5
msgid "|write1.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:21 dd677df19d3945d6bf16ede60e3d117b
msgid "write1.png"
msgstr ""

#: ../../en/base/rs232.rst:189 2b07e691e4fc46da81f06ef4c6717a8f
msgid "|write_line.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:22 46b214276a1d42a8b7bdddb28b2e2645
msgid "write_line.png"
msgstr ""

#: ../../en/base/rs232.rst:191 f3c93ed9a57a4053ada04928cd788b70
msgid "|write_list.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:23 304263438c724960a80d0c83c14023ea
msgid "write_list.png"
msgstr ""

#: ../../en/base/rs232.rst:193 8ea2b68d54aa4132ac89669ab2273ece
msgid "|write_raw_data.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:24 9527eeeb8a454d3599afe5c3d7a8d918
msgid "write_raw_data.png"
msgstr ""

#: ../../en/base/rs232.rst:195 0f7892de09f54f669c68fdb720662e7d
msgid "|write_raw_data_list.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:25 8c0dc91eaa66475b8807d78b2c4ef65f
msgid "write_raw_data_list.png"
msgstr ""

#: ../../en/base/rs232.rst:206 4e3c30cf3959418182fb9081299d8df7
msgid ""
"Send a break condition on the bus. This drives the bus low for a duration"
" longer than required for a normal transmission of a character."
msgstr "在总线上发送中断条件。这将使总线处于低电平，持续时间长于正常传输一个字符所需的时间。"

#: ../../en/base/rs232.rst:212 f82351a8d9c0489b993f6a5ce28ddbc9
msgid "|sendbreak.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:28 a330ad44ab304ebdb6e09e38a96a6448
msgid "sendbreak.png"
msgstr ""

#: ../../en/base/rs232.rst:222 3c8550ac755346b6886572f286178417
msgid ""
"Waits until all data has been sent. In case of a timeout, an exception is"
" raised. The timeout duration depends on the TX buffer size and the baud "
"rate. Unless flow control is enabled, a timeout should not occur."
msgstr "等待所有数据发送完毕。如果超时，则会出现异常。超时持续时间取决于发送缓冲区大小和波特率。除非启用了流量控制，否则不应发生超时。"

#: ../../en/base/rs232.rst:228 cd74a20dd5a64415b9522a61c1ee805a
msgid "|flush.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:27 e07465477b38405b8aa984bd489e2496
msgid "flush.png"
msgstr ""

#: ../../en/base/rs232.rst:238 a5fbd2bf410a44adab21677535af00c3
msgid ""
"Check whether all data has been sent or no data transfer is happening. "
"Returns ``True`` if no transmission is ongoing, otherwise returns "
"``False``."
msgstr "检查是否所有数据都已发送或没有数据传输。如果没有传输正在进行，则返回 ``True`` ，否则返回 ``False`` 。"

#: ../../en/base/rs232.rst:240 4e61f977396a4bf1a2910d3551e62edf
msgid "``True`` if no data transfer is happening, otherwise ``False``."
msgstr "如果没有数据传输，则返回 ``True``，否则返回 ``False``。"

#: ../../en/base/rs232.rst:245 5ed9bd024b58489390e6dee72cb3e06e
msgid "|txdone.png|"
msgstr ""

#: ../../en/refs/base.rs232.ref:26 41340a2b1e0e4c199ad38222bb0824ba
msgid "txdone.png"
msgstr ""

#~ msgid ""
#~ "poll = select.poll() poll.register(uart, "
#~ "select.POLLIN) poll.poll(timeout)"
#~ msgstr ""

#~ msgid "返回值：写入的字节数或超时时的 “无”。"
#~ msgstr ""

#~ msgid "|rs232|"
#~ msgstr ""

#~ msgid "rs232"
#~ msgstr ""

#~ msgid "|rs232 base|"
#~ msgstr ""

#~ msgid "Micropython RX Example:"
#~ msgstr "MicroPython 接收应用示例："

#~ msgid "|core_rs232_tx_example.m5f2|"
#~ msgstr ""

#~ msgid "|cores3_rs232_rx_example.m5f2|"
#~ msgstr ""

#~ msgid "class AtomRS232"
#~ msgstr ""

#~ msgid "Constructors"
#~ msgstr ""

#~ msgid "Construct a UART object of the given id."
#~ msgstr "根据给定的 id 构建 UART 对象。"

#~ msgid "For more parameters, please refer to init."
#~ msgstr "有关更多参数，请参阅初始设置。"

#~ msgid "UIFLOW2:"
#~ msgstr ""

#~ msgid "|init.png|"
#~ msgstr ""

#~ msgid "init.png"
#~ msgstr ""

#~ msgid "Methods"
#~ msgstr ""

#~ msgid "Initialise the UART bus with the given parameters:"
#~ msgstr "使用给定参数初始化 UART 总线："

#~ msgid "*baudrate* is the clock rate."
#~ msgstr "*baudrate* 是时钟频率"

#~ msgid "*bits* is the number of bits per character, 7, 8 or 9."
#~ msgstr "*bits* 是每个字符的位数，7、8 或 9。"

#~ msgid "*parity* is the parity, ``None``, 0 (even) or 1 (odd)."
#~ msgstr "*parity* 是奇偶校验，“无”、0（偶）或 1（奇）。"

#~ msgid "*stop* is the number of stop bits, 1 or 2."
#~ msgstr "*stop* 是停止位的位数，1 或 2。"

#~ msgid "Additional keyword-only parameters that may be supported by a port are:"
#~ msgstr "端口可能支持的其他关键字参数包括"

#~ msgid "*tx* specifies the TX pin to use."
#~ msgstr "*tx* 指定要使用的 TX 引脚。"

#~ msgid "*rx* specifies the RX pin to use."
#~ msgstr "*rx* 指定要使用的 RX 引脚。"

#~ msgid ""
#~ "*rts* specifies the RTS (output) pin "
#~ "to use for hardware receive flow "
#~ "control."
#~ msgstr "*rts* 指定用于硬件接收流量控制的 RTS（输出）引脚。"

#~ msgid ""
#~ "*cts* specifies the CTS (input) pin "
#~ "to use for hardware transmit flow "
#~ "control."
#~ msgstr "*cts* 指定用于硬件传输流控制的 CTS（输入）引脚。"

#~ msgid "*txbuf* specifies the length in characters of the TX buffer."
#~ msgstr "*txbuf* 指定 TX 缓冲区的长度（以字符为单位）。"

#~ msgid "*rxbuf* specifies the length in characters of the RX buffer."
#~ msgstr "*rxbuf* 指定 RX 缓冲区的长度（以字符为单位）。"

#~ msgid "*timeout* specifies the time to wait for the first character (in ms)."
#~ msgstr "*timeout* 指定等待第一个字符的时间（以毫秒为单位）"

#~ msgid "*timeout_char* specifies the time to wait between characters (in ms)."
#~ msgstr "*timeout_char* 指定字符之间的等待时间（以毫秒为单位）。"

#~ msgid "*invert* specifies which lines to invert."
#~ msgstr "*invert* 指定要反转的行。"

#~ msgid "``0`` will not invert lines (idle state of both lines is logic high)."
#~ msgstr "``0`` 不反转线路（两条线路的空闲状态均为逻辑高电平）。"

#~ msgid ""
#~ "``AtomRS232.INV_TX`` will invert TX line "
#~ "(idle state of TX line now logic"
#~ " low)."
#~ msgstr "``AtomRS232.INV_TX`` 将反转 TX 线路（TX 线路的空闲状态现在为逻辑低电平）。"

#~ msgid ""
#~ "``AtomRS232.INV_RX`` will invert RX line "
#~ "(idle state of RX line now logic"
#~ " low)."
#~ msgstr "``AtomRS232.INV_RX`` 将反转 RX 线路（RX 线路的空闲状态现在为逻辑低电平）。\""

#~ msgid ""
#~ "``AtomRS232.INV_TX | AtomRS232.INV_RX`` will "
#~ "invert both lines (idle state at "
#~ "logic low)."
#~ msgstr "``AtomRS232.INV_TX | AtomRS232.INV_RX`` 将反转两条线路（空闲状态为逻辑低电平）。"

#~ msgid ""
#~ "*flow* specifies which hardware flow "
#~ "control signals to use. The value "
#~ "is a bitmask."
#~ msgstr "*flow* 指定要使用的硬件流量控制信号。该值是一个位掩码。"

#~ msgid "``0`` will ignore hardware flow control signals."
#~ msgstr " ``0`` 将忽略硬件流量控制信号。"

#~ msgid ""
#~ "``AtomRS232.RTS`` will enable receive flow "
#~ "control by using the RTS output "
#~ "pin to signal if the receive FIFO"
#~ " has sufficient space to accept more"
#~ " data."
#~ msgstr "``AtomRS232.RTS`` 将启用接收流控制，方法是使用 RTS 输出引脚来指示接收 FIFO 是否有足够的空间接收更多数据。"

#~ msgid ""
#~ "``AtomRS232.CTS`` will enable transmit flow"
#~ " control by pausing transmission when "
#~ "the CTS input pin signals that the"
#~ " receiver is running low on buffer"
#~ " space."
#~ msgstr "``AtomRS232.CTS`` 将在 CTS 输入引脚发出接收器缓冲空间不足的信号时暂停传输，从而启用传输流控制。"

#~ msgid ""
#~ "``AtomRS232.RTS | AtomRS232.CTS`` will enable"
#~ " both, for full hardware flow "
#~ "control."
#~ msgstr "``AtomRS232.RTS | AtomRS232.CTS`` 将同时启用这两个功能，实现完全的硬件流量控制。"

#~ msgid ""
#~ "It is possible to call ``init()`` "
#~ "multiple times on the same object "
#~ "in order to reconfigure  UART on "
#~ "the fly. That allows using single "
#~ "UART peripheral to serve different "
#~ "devices attached to different GPIO pins."
#~ " Only one device can be served "
#~ "at a time in that case. Also "
#~ "do not call ``deinit()`` as it "
#~ "will prevent calling ``init()`` again."
#~ msgstr ""
#~ "可以在同一个对象上多次调用 ``init()``，以便在 UART 上重新配置。 "
#~ "以即时重新配置 UART。这样就可以使用单个 UART  外设为连接到不同 GPIO "
#~ "引脚的不同设备提供服务。 在这种情况下，一次只能为一个设备提供服务。也不要调用  "
#~ "``deinit()``，因为它会阻止再次调用 ``init()``。"

#~ msgid "|setup.png|"
#~ msgstr ""

#~ msgid "setup.png"
#~ msgstr ""

#~ msgid "Turn off the UART bus."
#~ msgstr ""

#~ msgid ""
#~ "You will not be able to call "
#~ "``init()`` on the object after "
#~ "``deinit()``. A new instance needs to"
#~ " be created in that case."
#~ msgstr "在 ``deinit()`` 之后，将无法对对象调用 ``init()`` 。在这种情况下，需要创建一个新实例。"

#~ msgid "|deinit.png|"
#~ msgstr ""

#~ msgid "deinit.png"
#~ msgstr ""

#~ msgid ""
#~ "Returns an integer counting the number"
#~ " of characters that can be read "
#~ "without blocking.  It will return 0 "
#~ "if there are no characters available "
#~ "and a positive number if there are"
#~ " characters.  The method may return 1"
#~ " even if there is more than one"
#~ " character available for reading."
#~ msgstr ""
#~ "返回一个整数，表示在不阻塞的情况下可读取的字符数。 如果没有可用字符，则返回 0；如果有可用字符，则返回正数。"
#~ " 即使有多个字符可供读取，该方法也可能返回 1。"

#~ msgid "|any.png|"
#~ msgstr ""

#~ msgid "any.png"
#~ msgstr ""

#~ msgid ""
#~ "Read characters.  If ``nbytes`` is "
#~ "specified then read at most that "
#~ "many bytes, otherwise read as much "
#~ "data as possible. It may return "
#~ "sooner if a timeout is reached. "
#~ "The timeout is configurable in the "
#~ "constructor."
#~ msgstr ""
#~ "读取字符。 如果指定了 ``nbytes`` "
#~ "，则最多读取这么多字节，否则读取尽可能多的数据。如果超时，可能会提前返回。超时时间可在构造函数中配置。"

#~ msgid ""
#~ "Return value: a bytes object containing"
#~ " the bytes read in.  Returns ``None``"
#~ " on timeout."
#~ msgstr "返回值：包含读入字节的字节对象。 超时时返回 ``无``。"

#~ msgid "|read_all.png|"
#~ msgstr ""

#~ msgid "read_all.png"
#~ msgstr ""

#~ msgid "|read_bytes.png|"
#~ msgstr ""

#~ msgid "read_bytes.png"
#~ msgstr ""

#~ msgid "|read_raw_data.png|"
#~ msgstr ""

#~ msgid "read_raw_data.png"
#~ msgstr ""

#~ msgid ""
#~ "Read bytes into the ``buf``.  If "
#~ "``nbytes`` is specified then read at "
#~ "most that many bytes.  Otherwise, read"
#~ " at most ``len(buf)`` bytes. It may"
#~ " return sooner if a timeout is "
#~ "reached. The timeout is configurable in"
#~ " the constructor."
#~ msgstr ""
#~ "向 ``buf`` 中读入字节。如果指定了 ``nbytes``，则最多读取这么多字节。 "
#~ "否则，最多读取 ``len(buf)`` 字节。如果超时，可能会提前返回。超时可在构造函数中配置。"

#~ msgid ""
#~ "Return value: number of bytes read "
#~ "and stored into ``buf`` or ``None`` "
#~ "on timeout."
#~ msgstr "返回值：读取并存储到 ``buf`` 的字节数，超时则为 ``None`` 。"

#~ msgid "|readinto.png|"
#~ msgstr ""

#~ msgid "readinto.png"
#~ msgstr ""

#~ msgid ""
#~ "Read a line, ending in a newline"
#~ " character. It may return sooner if"
#~ " a timeout is reached. The timeout"
#~ " is configurable in the constructor."
#~ msgstr "读取一行，以换行符结束。如果超时，可能会提前返回。超时时间可在构造函数中配置。"

#~ msgid "Return value: the line read or ``None`` on timeout."
#~ msgstr "返回值：读取的行或超时时的 “无”。"

#~ msgid "|readline.png|"
#~ msgstr ""

#~ msgid "readline.png"
#~ msgstr ""

#~ msgid "Write the buffer of bytes to the bus."
#~ msgstr "将字节缓冲区写入总线。"

#~ msgid "Return value: number of bytes written or ``None`` on timeout."
#~ msgstr "返回值：读取并存储到 ``buf`` 的字节数，超时则为 ``None`` 。"

#~ msgid "|write.png|"
#~ msgstr ""

#~ msgid "write.png"
#~ msgstr ""

#~ msgid "|write1.png|"
#~ msgstr ""

#~ msgid "write1.png"
#~ msgstr ""

#~ msgid "|write_line.png|"
#~ msgstr ""

#~ msgid "write_line.png"
#~ msgstr ""

#~ msgid "|write_list.png|"
#~ msgstr ""

#~ msgid "write_list.png"
#~ msgstr ""

#~ msgid "|write_raw_data.png|"
#~ msgstr ""

#~ msgid "write_raw_data.png"
#~ msgstr ""

#~ msgid "|write_raw_data_list.png|"
#~ msgstr ""

#~ msgid "write_raw_data_list.png"
#~ msgstr ""

#~ msgid ""
#~ "Send a break condition on the bus."
#~ " This drives the bus low for a"
#~ " duration longer than required for a"
#~ " normal transmission of a character."
#~ msgstr "在总线上发送中断条件。这将使总线处于低电平，持续时间超过正常传输一个字符所需的时间。"

#~ msgid "|sendbreak.png|"
#~ msgstr ""

#~ msgid "sendbreak.png"
#~ msgstr ""

#~ msgid ""
#~ "Waits until all data has been "
#~ "sent. In case of a timeout, an "
#~ "exception is raised. The timeout "
#~ "duration depends on the tx buffer "
#~ "size and the baud rate. Unless "
#~ "flow control is enabled, a timeout "
#~ "should not occur."
#~ msgstr "等待所有数据发送完毕。如果超时，则会出现异常。超时持续时间取决于发送缓冲区大小和波特率。除非启用了流量控制，否则不应发生超时。"

#~ msgid ""
#~ "For the rp2, esp8266 and nrf ports"
#~ " the call returns while the last "
#~ "byte is sent. If required, a one"
#~ " character wait time has to be "
#~ "added in the calling script."
#~ msgstr "对于 rp2、esp8266 和 nrf 端口，调用在发送最后一个字节时返回。如果需要，必须在调用脚本中添加一个字符的等待时间。"

#~ msgid "|flush.png|"
#~ msgstr ""

#~ msgid "flush.png"
#~ msgstr ""

#~ msgid ""
#~ "Tells whether all data has been "
#~ "sent or no data transfer is "
#~ "happening. In this case, it returns "
#~ "``True``. If a data transmission is "
#~ "ongoing it returns ``False``."
#~ msgstr "说明是否所有数据都已发送或没有数据传输。在这种情况下，它返回 ``True``。如果数据传输正在进行，则返回 ``假``。"

#~ msgid ""
#~ "For the rp2, esp8266 and nrf ports"
#~ " the call may return ``True`` even"
#~ " if the last byte of a transfer"
#~ " is still being sent. If required,"
#~ " a one character wait time has "
#~ "to be added in the calling script."
#~ msgstr ""
#~ "对于 rp2、esp8266 和 nrf "
#~ "端口，即使传输的最后一个字节仍在发送，调用也可能返回 ``真``。如果需要，必须在调用脚本中添加一个字符的等待时间。"

#~ msgid "|txdone.png|"
#~ msgstr ""

#~ msgid "txdone.png"
#~ msgstr ""

#~ msgid "tx_example.png"
#~ msgstr ""

#~ msgid "rx_example.png"
#~ msgstr ""

#~ msgid ""
#~ "This example demonstrates how to send"
#~ " data using the RS232 module via "
#~ "the UART interface."
#~ msgstr "本示例演示如何使用 RS232 模块通过 UART 接口发送数据。"

#~ msgid "|tx_example.png|"
#~ msgstr ""

#~ msgid "RX Example"
#~ msgstr ""

#~ msgid "Open the |cores3_rs232_rx_example.m5f2| project in UiFlow2."
#~ msgstr ""

#~ msgid "|rx_example.png|"
#~ msgstr ""

