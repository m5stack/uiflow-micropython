# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016 - 2025 M5Stack Technology Co., Ltd
# This file is distributed under the same license as the UIFlow2 Programming
# Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: UIFlow2 Programming Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:24+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/hardware/can.rst:4 ../../source/hardware/can.rst:19
#: 4bc44207f8794d0a9452a796f1b82c10 bdb3a44cab4143499a5a93b2b7d4cd7a
msgid "CAN"
msgstr ""

#: ../../source/hardware/can.rst:8 aa06108b3a60431aa5f8a0c7655f8ee2
msgid ""
"CAN currently only supports the classic CAN controller on ESP32 series. "
"At the physical level CAN bus consists of 2 lines: RX and TX.  Note that "
"to connect the M5Stack device to a CAN bus you must use a CAN transceiver"
" to convert the CAN logic signals from the MCU to the correct voltage "
"levels on the bus."
msgstr ""
"CAN目前仅支持ESP32系列上的经典CAN控制器。在物理层，CAN总线由RX和TX两条线路组成。"
"请注意，要将M5Stack设备连接到CAN总线，必须使用CAN收发器将MCU的CAN逻辑信号转换为"
"总线所需的正确电压电平。"

#: ../../source/hardware/can.rst:13 76bdcbb11a134ff3a420f1ef3e76704d
msgid "For detailed examples, please refer to: :ref:`unit.CANUnit <unit.CANUnit>`"
msgstr "详细示例请参阅：:ref:`unit.CANUnit <unit.CANUnit>`"

#: ../../source/hardware/can.rst:16 2124757b9d924fe4ad344c0eb093b098
msgid "API"
msgstr "API参考"

#: ../../source/hardware/can.rst:23 3231ef828f374e54ad3738024e19271f
msgid "Construct a CAN object on the given bus."
msgstr "在指定总线上构造一个CAN对象。"

#: ../../source/hardware/can.rst 297e274506ff4d3db130fd0bcf6f765d
msgid "Parameters"
msgstr ""

#: ../../source/hardware/can.rst:25 620a6890e16345f99fdd26354eddcce8
msgid "must be 0."
msgstr "必须为0。"

#: ../../source/hardware/can.rst:26 ../../source/hardware/can.rst:51
#: 607af29ad6044cf09f1aa193c23a34de
msgid "One of NORMAL, NO_ACKNOWLEDGE, LISTEN_ONLY."
msgstr "取值为NORMAL、NO_ACKNOWLEDGE或LISTEN_ONLY之一。"

#: ../../source/hardware/can.rst:27 ../../source/hardware/can.rst:52
#: 2967e589a46f483c889f592cb52d5196
msgid "The pin to use for transmitting data."
msgstr "用于发送数据的引脚。"

#: ../../source/hardware/can.rst:28 ../../source/hardware/can.rst:53
#: ef7e3addfea24f368315ff438556f5be
msgid "The pin to use for receiving data."
msgstr "用于接收数据的引脚。"

#: ../../source/hardware/can.rst:29 24c6e3a5049949dfb86be0308d6cc3a6
msgid ""
"The value by which the CAN input clock is divided to generate the nominal"
" bit time quanta. Value between 1 and 1024 inclusive for classic CAN."
msgstr ""
"将CAN输入时钟分频以生成名义位时间量化值的分频数，经典CAN取值范围为1到1024。"

#: ../../source/hardware/can.rst:30 7228967e7fbb4757a9fe16090582443c
msgid ""
"The resynchronisation jump width in units of time quanta for nominal "
"bits; value between 1 and 4 inclusive for classic CAN."
msgstr ""
"名义位的时间量化单位中的重同步跳转宽度，经典CAN取值范围为1到4。"

#: ../../source/hardware/can.rst:31 6ab3accb7a8c4f8c87488cf6b2e2b591
msgid ""
"Defines the location of the sample point in units of the time quanta for "
"nominal bits; value between 1 and 16 inclusive for classic CAN."
msgstr ""
"定义名义位中采样点在时间量化单位中的位置，经典CAN取值范围为1到16。"

#: ../../source/hardware/can.rst:32 bdebe11f470e49ea818c60cc4c8dd54d
msgid ""
"Defines the location of the transmit point in units of the time quanta "
"for nominal bits; value between 1 and 8 inclusive for classic CAN."
msgstr ""
"定义名义位中发送点在时间量化单位中的位置，经典CAN取值范围为1到8。"

#: ../../source/hardware/can.rst:33 ../../source/hardware/can.rst:58
#: c531a8b028ca4c7f9c8f6e4d7a41eab0
msgid "Enables triple sampling when the TWAI controller samples a bit."
msgstr "当TWAI控制器采样位时启用三重采样。"

#: ../../source/hardware/can.rst:35 ../../source/hardware/can.rst:85
#: ../../source/hardware/can.rst:105 ../../source/hardware/can.rst:126
#: ../../source/hardware/can.rst:154 ../../source/hardware/can.rst:171
#: ../../source/hardware/can.rst:217 ../../source/hardware/can.rst:247
#: ddd21ed006f6480cb55b8061e9dfb595
msgid "UiFlow2 Code Block:"
msgstr "UiFlow2 代码块："

#: ../../source/hardware/can.rst:37 c150ad6e2a6c470ebc27eacb8e2e3d25
msgid "|init.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:1 7c3a53a64a2640868426535159fcbc47
msgid "init.png"
msgstr ""

#: ../../source/hardware/can.rst:39 ../../source/hardware/can.rst:75
#: ../../source/hardware/can.rst:89 ../../source/hardware/can.rst:109
#: ../../source/hardware/can.rst:130 ../../source/hardware/can.rst:158
#: ../../source/hardware/can.rst:175 ../../source/hardware/can.rst:223
#: ../../source/hardware/can.rst:251 982dd24cd8674a33a6bf320ba84084aa
msgid "MicroPython Code Block:"
msgstr "MicroPython 代码块："

#: ../../source/hardware/can.rst:49 3231ef828f374e54ad3738024e19271f
msgid "Initialise the CAN bus with the given parameters."
msgstr "使用给定参数初始化CAN总线。"

#: ../../source/hardware/can.rst:54 24c6e3a5049949dfb86be0308d6cc3a6
msgid ""
"The value by which the CAN input clock is divided to generate the nominal"
" bit time quanta."
msgstr "用于将 CAN 输入时钟分频以生成名义位时间量化值的分频数。"

#: ../../source/hardware/can.rst:55 7228967e7fbb4757a9fe16090582443c
msgid "The resynchronisation jump width in units of time quanta for nominal bits."
msgstr "名义位的时间量化单位中的重同步跳转宽度。"

#: ../../source/hardware/can.rst:56 6ab3accb7a8c4f8c87488cf6b2e2b591
msgid ""
"Defines the location of the sample point in units of the time quanta for "
"nominal bits."
msgstr "定义采样点在名义位时间量化单位中的位置。"

#: ../../source/hardware/can.rst:57 bdebe11f470e49ea818c60cc4c8dd54d
msgid ""
"Defines the location of the transmit point in units of the time quanta "
"for nominal bits."
msgstr "定义发送点在名义位时间量化单位中的位置。"

#: ../../source/hardware/can.rst:60 9327fcf36ec243e382487099290fcdbb
msgid ""
"The time quanta tq is the basic unit of time for the CAN bus.  tq is the "
"CAN prescaler value divided by APB_CLK clock source (typically 80 MHz);"
msgstr ""
"时间量化tq是 CAN 总线的基本时间单位，tq等于 CAN 预分频值除以 APB_CLK 时钟源（通常为"
"80 MHz）。"

#: ../../source/hardware/can.rst:63 21e666ea6e7a4b2482ce367a41a99056
msgid ""
"A single bit is made up of the synchronisation segment, which is always 1"
" tq. Then follows bit segment 1, then bit segment 2.  The sample point is"
" after bit segment 1 finishes.  The transmit point is after bit segment 2"
" finishes. The baud rate will be 1/bittime, where the bittime is 1 + BS1 "
"+ BS2 multiplied by the time quanta tq."
msgstr ""
"单个位由同步段组成，该段始终为1个tq，之后依次为位段1和位段2。采样点位于位段1结束"
"后，发送点位于位段2结束后。波特率为1/位时间，其中位时间为(1 + BS1 + BS2)乘以时间"
"量化tq。"

#: ../../source/hardware/can.rst:69 2c8a88dbdb0e403193c143140fc3c536
msgid ""
"For example, with APB_CLK=80MHz, prescaler=32, sjw=3, bs1=15, bs2=4, the "
"value of tq is 0.4 microseconds.  The bittime is 8 microseconds, and the "
"baudrate is 125kHz."
msgstr ""
"例如，当APB_CLK=80MHz、prescaler=32、sjw=3、bs1=15、bs2=4时，tq为0.4微秒，位时间"
"为8微秒，波特率为125kHz。"

#: ../../source/hardware/can.rst:73 fd6642018375491da7ea691c4ca85afa
msgid "See esp32 technical reference manual for more details."
msgstr "更多信息请参阅ESP32技术参考手册。"

#: ../../source/hardware/can.rst:83 e4e0740d4f09453a9c947af63712bafc
msgid "Turn off the CAN bus."
msgstr "关闭CAN总线。"

#: ../../source/hardware/can.rst:87 6e9013d349854cd8aa9fd6c5a18c3964
msgid "|deinit.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:3 3bddf6c5fc424e529dba7937e0794a28
msgid "deinit.png"
msgstr ""

#: ../../source/hardware/can.rst:97 e72c7cfc01a741fcbe1ccfcbc83ecbd8
msgid ""
"Force a software restart of the CAN controller without resetting its "
"configuration."
msgstr "在不重置配置的情况下强制软件重启CAN控制器。"

#: ../../source/hardware/can.rst:99 d715d3b4b0d0461ca34174cf972e03de
msgid ""
"If the controller enters the bus-off state then it will no longer "
"participate in bus activity.  If the controller is not configured to "
"automatically restart (see :meth:\\`~CAN.init()\\`) then this method can "
"be used to trigger a restart, and the controller will follow the CAN "
"protocol to leave the bus-off state and go into the error active state."
msgstr ""
"如果控制器进入总线关闭状态，它将不再参与总线活动。若控制器未配置自动重启（参见"
" :meth:\\`~CAN.init()\\`），可以通过此方法触发重启，控制器将按照CAN协议离开总线关闭状"
"态并进入错误活动状态。"

#: ../../source/hardware/can.rst:107 929a27e106f44928b5d86d75502ca5c1
msgid "|restart.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:5 d81e757540d14acd9e5e01cf805f952a
msgid "restart.png"
msgstr ""

#: ../../source/hardware/can.rst:117 ccbbf448e9554db5b10a74dd8e5e61a1
msgid "Return the state of the controller."
msgstr "返回控制器状态。"

#: ../../source/hardware/can.rst e012b4df59cf4de5a216a77e90641bd5
msgid "Returns"
msgstr ""

#: ../../source/hardware/can.rst:119 32b0dc69aefb480c839f6b2968c171a2
msgid "int"
msgstr ""

#: ../../source/hardware/can.rst:121 4b78f25cf8194f63a0901e6d6be96944
msgid ""
"\\`\\`0\\`\\` -- \\`\\`CAN.STOPPED\\`\\` : the controller is completely "
"off and reset;"
msgstr "\\`\\`0\\`\\` -- \\`\\`CAN.STOPPED\\`\\`：控制器完全关闭并复位；"

#: ../../source/hardware/can.rst:122 3a7e5054f4a94b66b7a78ae9d8e1fbe7
msgid ""
"\\`\\`4\\`\\` -- \\`\\`CAN.BUS_OFF\\`\\` : the controller is on but not "
"participating in bus activity (TEC overflowed beyond 255);"
msgstr "\\`\\`4\\`\\` -- \\`\\`CAN.BUS_OFF\\`\\`：控制器仍开启但不再参与总线（TEC溢出超过255）；"

#: ../../source/hardware/can.rst:123 a009e3dd1faa4545a9140249a7d89bb5
msgid ""
"\\`\\`5\\`\\` -- \\`\\`CAN.RECOVERING\\`\\` -- The controller is "
"undergoing bus recovery."
msgstr "\\`\\`5\\`\\` -- \\`\\`CAN.RECOVERING\\`\\`：控制器正在进行总线恢复。"

#: ../../source/hardware/can.rst:124 a345d6e5512c426f9a7c4fabf76a4d95
msgid ""
"\\`\\`6\\`\\` -- \\`\\`CAN.RUNNING\\`\\` : The controller can transmit "
"and receive messages;"
msgstr "\\`\\`6\\`\\` -- \\`\\`CAN.RUNNING\\`\\`：控制器可以发送并接收消息；"

#: ../../source/hardware/can.rst:128 ee011a10f9064647a8b7ca1946ea3318
msgid "|state.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:7 fc173015f1b64056bee1774a846de992
msgid "state.png"
msgstr ""

#: ../../source/hardware/can.rst:138 ce7df52677094857b26400d57b2c3fae
msgid "Get information about the controller's error states and TX and RX buffers."
msgstr "获取控制器的错误状态以及 TX 和 RX 缓冲区信息。"

#: ../../source/hardware/can.rst:140 a67a8721a9eb4734b0c6ae0eaf2be81b
msgid "Optional list object with at least 8 entries."
msgstr "可选列表对象，至少包含8个元素。"

#: ../../source/hardware/can.rst:141 124c482f17e54c32b24d80fb5c5cdefa
msgid "list"
msgstr ""

#: ../../source/hardware/can.rst:143 8b8e3e233e4c46fba2fb9a5835e16404
msgid "The values in the list are:"
msgstr "列表中的值包括："

#: ../../source/hardware/can.rst:145 388285cbdda34fc5848c8458acf882de
msgid "TEC value"
msgstr "TEC 值"

#: ../../source/hardware/can.rst:146 bdef33eb07604e4f821a7d664ff3c27a
msgid "REC value"
msgstr "REC 值"

#: ../../source/hardware/can.rst:147 36fb9a966861429890e8c121d2656a75
msgid ""
"number of times the controller enterted the Error Warning state(ignored "
"for now, compatible with pyb.CAN)"
msgstr "控制器进入错误警告状态的次数（暂不使用，与pyb.CAN兼容）。"

#: ../../source/hardware/can.rst:148 3a2e81d842bc42b493b9d39cacd261b0
msgid ""
"number of times the controller enterted the Error Passive state(ignored "
"for now, compatible with pyb.CAN)"
msgstr "控制器进入错误被动状态的次数（暂不使用，与pyb.CAN兼容）。"

#: ../../source/hardware/can.rst:149 925766dcd85e4947934a55265e95770a
msgid ""
"number of times the controller enterted the Bus Off state(ignored for "
"now, compatible with pyb.CAN)"
msgstr "控制器进入总线关闭状态的次数（暂不使用，与pyb.CAN兼容）。"

#: ../../source/hardware/can.rst:150 3ca2d22e1dd847a1962fa2d14f4e97bb
msgid "number of pending TX messages"
msgstr "待发送消息数量"

#: ../../source/hardware/can.rst:151 8a11148539d24f4d9a92c05bf25baf63
msgid "number of pending RX messages"
msgstr "待接收消息数量"

#: ../../source/hardware/can.rst:152 2e37457be0114c528494d55bef90172b
msgid ""
"number of pending RX messages on fifo 1(ignored for now, compatible with "
"pyb.CAN)"
msgstr "fifo 1中的待接收消息数量（暂不使用，与pyb.CAN兼容）。"

#: ../../source/hardware/can.rst:156 a35b06b9247b461f837c1cc99565495a
msgid "|info.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:9 7c7300d2631a4b9db62ec27e288b465e
msgid "info.png"
msgstr ""

#: ../../source/hardware/can.rst:166 200637e1322d4339a1f934298e86f1de
msgid ""
"Return \\`\\`True\\`\\` if any message waiting on the FIFO, else "
"\\`\\`False\\`\\`."
msgstr "若FIFO中存在待处理消息则返回\\`\\`True\\`\\`，否则返回\\`\\`False\\`\\`。"

#: ../../source/hardware/can.rst:168 926c4fed3f6e481cbd354e35b7d28e20
msgid "FIFO index."
msgstr "FIFO 索引。"

#: ../../source/hardware/can.rst:169 bf6a19239197489bb7a70537b017b1fd
msgid "bool"
msgstr ""

#: ../../source/hardware/can.rst:173 799c2aff21394cbcb33fb078bc8705fb
msgid "|any.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:11 f1efd0bb798141fdace0c2d9e595db12
msgid "any.png"
msgstr ""

#: ../../source/hardware/can.rst:184 54dbed5766f343ffbbe51e5ed95ddc68
msgid "Receive data on the bus."
msgstr "在总线上接收数据。"

#: ../../source/hardware/can.rst:186 079f394b855246c488650b01591fffc8
msgid "fifo is an integer, it can be any number and compatible with pyb.CAN"
msgstr "fifo为整数，可为任意数值，与pyb.CAN兼容。"

#: ../../source/hardware/can.rst:187 a67a8721a9eb4734b0c6ae0eaf2be81b
msgid "optional list object to be used as the return value"
msgstr "可选的列表对象，用作返回值。"

#: ../../source/hardware/can.rst:188 f58c59911bdc495b99882af8a89af763
msgid "timeout in milliseconds to wait for the receive."
msgstr "等待接收的超时时间（毫秒）。"

#: ../../source/hardware/can.rst:189 ef90746fc5ac41e8aca951c0475a1d19
msgid "tuple"
msgstr ""

#: ../../source/hardware/can.rst:191 62d3e23b12eb4bba9123548aa9cf0b41
msgid "Return value: A tuple containing five values."
msgstr "返回值：包含5个元素的元组。"

#: ../../source/hardware/can.rst:193 9f83bd99ed2f421d9414ec1f27f4aa78
msgid "The id of the message."
msgstr "消息 ID。"

#: ../../source/hardware/can.rst:194 98ba9261130c4efcb1cc1e53938a5b94
msgid "A boolean that indicates if the message ID is standard or extended."
msgstr "布尔值，指示消息 ID为标准帧或扩展帧。"

#: ../../source/hardware/can.rst:195 b38bdcac4fda4e82b98217fdb27d6255
msgid "A boolean that indicates if the message is an RTR message."
msgstr "布尔值，指示消息是否为RTR消息。"

#: ../../source/hardware/can.rst:196 4e8e4968758c42aab52c29953eba61b8
msgid "The FMI (Filter Match Index) value."
msgstr "FMI（滤波匹配索引）值。"

#: ../../source/hardware/can.rst:197 3b58af4aa6624cb1bd5d76f4cfedf950
msgid "An array containing the data."
msgstr "包含数据的数组。"

#: ../../source/hardware/can.rst:199 fc515fd284ea4a40923bec16aa306376
msgid ""
"If *list* is \\`\\`None\\`\\` then a new tuple will be allocated, as well"
" as a new bytes object to contain the data (as the fifth element in the "
"tuple)."
msgstr ""
"如果 *list* 为\\`\\`None\\`\\`，将分配一个新的元组以及一个新的bytes对象（作为元组的第"
"五个元素）来存放数据。"

#: ../../source/hardware/can.rst:202 c0768c68b5fc4f6587d8d6fb670ffcf2
msgid ""
"If *list* is not \\`\\`None\\`\\` then it should be a list object with a "
"least five elements.  The fifth element should be a memoryview object "
"which is created from either a bytearray or an array of type 'B' or 'b', "
"and this array must have enough room for at least 8 bytes.  The list "
"object will then be populated with the first four return values above, "
"and the memoryview object will be resized inplace to the size of the data"
" and filled in with that data. The same list and memoryview objects can "
"be reused in subsequent calls to this method, providing a way of "
"receiving data without using the heap. For example::"
msgstr ""
"如果 *list* 不是\\`\\`None\\`\\`，则它应是包含至少5个元素的列表。第五个元素必须是由"
"bytearray或类型为'B'或'b'的array创建的memoryview对象，并且该数组至少能容纳8个字"
"节。列表会填充前四个返回值，而memoryview会就地调整到数据长度并写入数据。同一列表"
"和memoryview可以在后续调用中复用，从而避免使用堆内存。例如::"

#: ../../source/hardware/can.rst:219 a4a5d311e39a4ce29602447dd82439c4
msgid "|recv1.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:13 70bc85ae514f4bd887246ecdc1eebe1b
msgid "recv1.png"
msgstr ""

#: ../../source/hardware/can.rst:221 99036735ab1b4722ae587a1497a46d3c
msgid "|recv2.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:15 01b3a27aea3e469c9aa7a38a2516a61a
msgid "recv2.png"
msgstr ""

#: ../../source/hardware/can.rst:231 c5700f4b0abd49e2870f48b7e1185124
msgid "Send a message on the bus."
msgstr "在总线上发送消息。"

#: ../../source/hardware/can.rst:233 10ddf4dfb2614868963fbd64697685e8
msgid "data is the data to send (an integer to send, or a buffer object)."
msgstr "data为要发送的数据（可以是整数或缓冲对象）。"

#: ../../source/hardware/can.rst:234 19c6811dac1f460daa11a0a525377585
msgid "id is the id of the message to be sent."
msgstr "id为要发送的消息ID。"

#: ../../source/hardware/can.rst:235 cd70334a40b14d70bf8bb07a8f92602b
msgid "timeout is the timeout in milliseconds to wait for the send."
msgstr "timeout为等待发送的超时时间（毫秒）。"

#: ../../source/hardware/can.rst:236 cd901651b8494984b0c3d17167f09b44
msgid ""
"rtr is a boolean that specifies if the message shall be sent as a remote "
"transmission request. If rtr is True then only the length of data is used"
" to fill in the DLC slot of the frame; the actual bytes in data are "
"unused."
msgstr ""
"rtr是布尔值，指示是否以远程帧发送消息。若rtr为True，则仅使用data的长度填充帧的D"
"LC字段，data中的字节不会被使用。"

#: ../../source/hardware/can.rst:237 8344dec465a14c699cdb082da3052fe3
msgid ""
"extframe if True the frame will have an extended identifier (29 bits), "
"otherwise a standard identifier (11 bits) is used."
msgstr ""
"extframe为True时帧使用扩展标识符（29位），否则使用标准标识符（11位）。"

#: ../../source/hardware/can.rst:239 cf598156879b451394d821b47db3b797
msgid ""
"If timeout is 0 the message is placed in a buffer in one of three "
"hardware buffers and the method returns immediately. If all three buffers"
" are in use an exception is thrown. If timeout is not 0, the method waits"
" until the message is transmitted. If the message can't be transmitted "
"within the specified time an exception is thrown."
msgstr ""
"当timeout为0时，消息会被放入三个硬件缓冲区之一并立即返回；如果三个缓冲区都在使"
"用，则会抛出异常。timeout非0时，方法会等待消息发送；若在指定时间内无法发送成功"
"则抛出异常。"

#: ../../source/hardware/can.rst:245 307f196a0aa04fb2bf389d73e73361b3
msgid "None"
msgstr ""

#: ../../source/hardware/can.rst:249 225256a7c23b4d4ab12744628d183656
msgid "|send.png|"
msgstr ""

#: ../../source/refs/hardware.can.ref:17 73dba36f4c03453496ddb8d242ae5ad3
msgid "send.png"
msgstr ""

#: ../../source/hardware/can.rst:261 c696e0aef5fa4187989c0ac371ae4b5c
msgid "The mode of the CAN bus used in :meth:\\`~CAN.init()\\`."
msgstr "在 :meth:\\`~CAN.init()\\` 中使用的CAN总线模式。"

#: ../../source/hardware/can.rst:268 85df0fc996744c0b82193cdbd6c6ba93
msgid ""
"Possible states of the CAN controller returned from "
":meth:\\`~CAN.state()\\`."
msgstr " :meth:\\`~CAN.state()\\` 返回的CAN控制器可能状态。"

#~ msgid "|init.svg|"
#~ msgstr ""

#~ msgid "init.svg"
#~ msgstr ""

#~ msgid "|deinit.svg|"
#~ msgstr ""

#~ msgid "deinit.svg"
#~ msgstr ""

#~ msgid "|restart.svg|"
#~ msgstr ""

#~ msgid "restart.svg"
#~ msgstr ""

#~ msgid "|state.svg|"
#~ msgstr ""

#~ msgid "state.svg"
#~ msgstr ""

#~ msgid "|info.svg|"
#~ msgstr ""

#~ msgid "info.svg"
#~ msgstr ""

#~ msgid "|any.svg|"
#~ msgstr ""

#~ msgid "any.svg"
#~ msgstr ""

#~ msgid "|recv1.svg|"
#~ msgstr ""

#~ msgid "recv1.svg"
#~ msgstr ""

#~ msgid "|recv2.svg|"
#~ msgstr ""

#~ msgid "recv2.svg"
#~ msgstr ""

#~ msgid "|send.svg|"
#~ msgstr ""

#~ msgid "send.svg"
#~ msgstr ""

#~ msgid "``CAN.STOPPED`` -- the controller is completely off and reset;"
#~ msgstr ""

#~ msgid "``CAN.RUNNING`` -- The controller can transmit and receive messages;"
#~ msgstr ""

#~ msgid ""
#~ "``CAN.BUS_OFF`` -- the controller is on"
#~ " but not participating in bus "
#~ "activity (TEC overflowed beyond 255);"
#~ msgstr ""

#~ msgid "``RECOVERING`` -- The controller is undergoing bus recovery."
#~ msgstr ""

#~ msgid ""
#~ "CAN implements support for classic CAN"
#~ " (available on F4, F7 MCUs) and "
#~ "CAN FD (H7 series) controllers. At "
#~ "the physical level CAN bus consists "
#~ "of 2 lines: RX and TX.  Note "
#~ "that to connect the pyboard to a"
#~ " CAN bus you must use a CAN "
#~ "transceiver to convert the CAN logic "
#~ "signals from the pyboard to the "
#~ "correct voltage levels on the bus."
#~ msgstr ""

#~ msgid ""
#~ "Example usage for classic CAN controller"
#~ " in Loopback (transceiver-less) mode::"
#~ msgstr ""

#~ msgid "Constructors"
#~ msgstr ""

#~ msgid ""
#~ "Construct a CAN object on the "
#~ "given bus.  *bus* must be 0. With"
#~ " no additional parameters, the CAN "
#~ "object is created but not initialised"
#~ " (it has the settings from the "
#~ "last initialisation of the bus, if "
#~ "any).  If extra arguments are given, "
#~ "the bus is initialised. See "
#~ ":meth:`CAN.init` for parameters of "
#~ "initialisation."
#~ msgstr ""

#~ msgid "UIFLOW2:"
#~ msgstr ""

#~ msgid "Methods"
#~ msgstr ""

#~ msgid "Initialise the CAN bus with the given parameters:"
#~ msgstr ""

#~ msgid "*mode* is one of:  NORMAL, NO_ACKNOWLEDGE, LISTEN_ONLY"
#~ msgstr ""

#~ msgid "*tx* is the pin to use for transmitting data"
#~ msgstr ""

#~ msgid "*rx* is the pin to use for receiving data"
#~ msgstr ""

#~ msgid ""
#~ "*prescaler* is the value by which "
#~ "the CAN input clock is divided to"
#~ " generate the nominal bit time "
#~ "quanta. The prescaler can be a "
#~ "value between 1 and 1024 inclusive "
#~ "for classic CAN."
#~ msgstr ""

#~ msgid ""
#~ "*sjw* is the resynchronisation jump "
#~ "width in units of time quanta for"
#~ " nominal bits; it can be a "
#~ "value between 1 and 4 inclusive "
#~ "for classic CAN."
#~ msgstr ""

#~ msgid ""
#~ "*bs1* defines the location of the "
#~ "sample point in units of the time"
#~ " quanta for nominal bits; it can "
#~ "be a value between 1 and 16 "
#~ "inclusive for classic CAN."
#~ msgstr ""

#~ msgid ""
#~ "*bs2* defines the location of the "
#~ "transmit point in units of the "
#~ "time quanta for nominal bits; it "
#~ "can be a value between 1 and "
#~ "8 inclusive for classic CAN."
#~ msgstr ""

#~ msgid ""
#~ "*triple_sampling* is Enables triple sampling"
#~ " when the TWAI controller samples a"
#~ " bit"
#~ msgstr ""

#~ msgid ""
#~ "If the controller enters the bus-"
#~ "off state then it will no longer"
#~ " participate in bus activity.  If the"
#~ " controller is not configured to "
#~ "automatically restart (see :meth:`~CAN.init()`) "
#~ "then this method can be used to"
#~ " trigger a restart, and the "
#~ "controller will follow the CAN protocol"
#~ " to leave the bus-off state and"
#~ " go into the error active state."
#~ msgstr ""

#~ msgid "Return the state of the controller.  The return value can be one of:"
#~ msgstr ""

#~ msgid "``0`` -- ``CAN.STOPPED`` : the controller is completely off and reset;"
#~ msgstr ""

#~ msgid ""
#~ "``4`` -- ``CAN.BUS_OFF`` : the "
#~ "controller is on but not participating"
#~ " in bus activity (TEC overflowed "
#~ "beyond 255);"
#~ msgstr ""

#~ msgid ""
#~ "``5`` -- ``CAN.RECOVERING`` -- The "
#~ "controller is undergoing bus recovery."
#~ msgstr ""

#~ msgid ""
#~ "``6`` -- ``CAN.RUNNING`` : The "
#~ "controller can transmit and receive "
#~ "messages;"
#~ msgstr ""

#~ msgid ""
#~ "Get information about the controller's "
#~ "error states and TX and RX "
#~ "buffers. If *list* is provided then "
#~ "it should be a list object with"
#~ " at least 8 entries, which will "
#~ "be filled in with the information.  "
#~ "Otherwise a new list will be "
#~ "created and filled in.  In both "
#~ "cases the return value of the "
#~ "method is the populated list."
#~ msgstr ""

#~ msgid "Return ``True`` if any message waiting on the FIFO, else ``False``."
#~ msgstr ""

#~ msgid "Receive data on the bus:"
#~ msgstr ""

#~ msgid "*fifo* is an integer, it can be any number and compatible with pyb.CAN"
#~ msgstr ""

#~ msgid "*list* is an optional list object to be used as the return value"
#~ msgstr ""

#~ msgid "*timeout* is the timeout in milliseconds to wait for the receive."
#~ msgstr ""

#~ msgid ""
#~ "If *list* is ``None`` then a new"
#~ " tuple will be allocated, as well "
#~ "as a new bytes object to contain"
#~ " the data (as the fifth element "
#~ "in the tuple)."
#~ msgstr ""

#~ msgid ""
#~ "If *list* is not ``None`` then it"
#~ " should be a list object with a"
#~ " least five elements.  The fifth "
#~ "element should be a memoryview object"
#~ " which is created from either a "
#~ "bytearray or an array of type 'B'"
#~ " or 'b', and this array must "
#~ "have enough room for at least 8"
#~ " bytes.  The list object will then"
#~ " be populated with the first four "
#~ "return values above, and the memoryview"
#~ " object will be resized inplace to"
#~ " the size of the data and "
#~ "filled in with that data. The same"
#~ " list and memoryview objects can be"
#~ " reused in subsequent calls to this"
#~ " method, providing a way of receiving"
#~ " data without using the heap. For "
#~ "example::"
#~ msgstr ""

#~ msgid "Send a message on the bus:"
#~ msgstr ""

#~ msgid "*data* is the data to send (an integer to send, or a buffer object)."
#~ msgstr ""

#~ msgid "*id* is the id of the message to be sent."
#~ msgstr ""

#~ msgid "*timeout* is the timeout in milliseconds to wait for the send."
#~ msgstr ""

#~ msgid ""
#~ "*rtr* is a boolean that specifies "
#~ "if the message shall be sent as"
#~ " a remote transmission request.  If "
#~ "*rtr* is True then only the length"
#~ " of *data* is used to fill in"
#~ " the DLC slot of the frame; the"
#~ " actual bytes in *data* are unused."
#~ msgstr ""

#~ msgid ""
#~ "*extframe* if True the frame will "
#~ "have an extended identifier (29 bits),"
#~ " otherwise a standard identifier (11 "
#~ "bits) is used."
#~ msgstr ""

#~ msgid "Return value: ``None``."
#~ msgstr ""

#~ msgid "Constants"
#~ msgstr ""

#~ msgid "The mode of the CAN bus used in :meth:`~CAN.init()`."
#~ msgstr ""

#~ msgid ""
#~ "Possible states of the CAN controller"
#~ " returned from :meth:`~CAN.state()`."
#~ msgstr ""

#~ msgid "UiFlow2 Example"
#~ msgstr ""

#~ msgid "Example1"
#~ msgstr ""

#~ msgid "This example demonstrates how to use the \\`\\`CAN\\`\\` class."
#~ msgstr ""

#~ msgid ""
#~ "(Please refer to :ref:\\`unit.CANUnit "
#~ "<unit.CANUnit>\\` for UiFlow2 examples)"
#~ msgstr ""

#~ msgid "Example output:"
#~ msgstr ""

#~ msgid "Msg Recveived: ID: 0x123 Data: 0x11 0x22 0x33 0x44"
#~ msgstr ""

#~ msgid "MicroPython Example"
#~ msgstr ""

#~ msgid ""
#~ "Example usage for classic CAN controller"
#~ " in Loopback (transceiver-less) mode."
#~ msgstr ""

#~ msgid "(123, False, False, 0, bytearray(b'message!'))"
#~ msgstr ""

